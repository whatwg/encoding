<pre class='metadata'>
Title: Encoding Standard
H1: Encoding
Shortname: encoding
Status: LS
Group: WHATWG
No Editor: true
!Participate: <a href=https://github.com/whatwg/encoding>GitHub whatwg/encoding</a> (<a href=https://github.com/whatwg/encoding/issues/new>file an issue</a>, <a href=https://github.com/whatwg/encoding/issues>open issues</a>)
!Participate: <a href=https://wiki.whatwg.org/wiki/IRC>IRC: #whatwg on Freenode</a>
!Commits: <a href=https://github.com/whatwg/encoding/commits>GitHub whatwg/encoding/commits</a>
!Commits: <a href=https://twitter.com/encodings>@encodings</a>
Logo: https://resources.whatwg.org/logo-encoding.svg
Abstract: ...
Boilerplate: omit conformance, omit feedback-header
</pre>
<!--
 <dt>Translation <small>(non-normative)</small>:
 <dd title=Japanese><a href=https://triple-underscore.github.io/Encoding-ja.html lang=ja hreflang=ja rel=alternate>Êó•Êú¨Ë™û</a>
-->

<script src=https://resources.whatwg.org/file-issue.js async></script>

<h2>Preface</h2>

<p>The UTF-8 encoding is the most appropriate encoding for interchange of Unicode, the
universal coded character set. Therefore for new protocols and formats, as well as
existing formats deployed in new contexts, this specification requires (and defines) the
UTF-8 encoding.

<p>The other (legacy) encodings have been defined to some extent in the past. However,
user agents have not always implemented them in the same way, have not always used the
same labels, and often differ in dealing with undefined and former proprietary areas of
encodings. This specification addresses those gaps so that new user agents do not have to
reverse engineer encoding implementations and existing user agents can converge.

<p>In particular, this specification defines all those encodings, their algorithms to go
from bytes to scalar values and back, and their canonical names and identifying labels.
This specification also defines an API to expose part of the encoding algorithms to
JavaScript.

<p>User agents have also significantly deviated from the labels listed in the
<a href="https://www.iana.org/assignments/character-sets/character-sets.xhtml">IANA Character Sets registry</a>.
To stop spreading legacy encodings further, this specification is exhaustive about the
aforementioned details and therefore has no need for the registry. In particular, this
specification does not provide a mechanism for extending any aspect of encodings.



<h2>Security background</h2>

<p>There is a set of encoding security issues when the producer and consumer do not agree
on the encoding in use, or on the way a given encoding is to be implemented. For instance,
an attack was reported in 2011 where a <a>Shift_JIS</a> lead byte 0x82 was used to
‚Äúmask‚Äù a 0x22 trail byte in a JSON resource of which an attacker could control some field.
The producer did not see the problem even though this is an illegal byte combination. The
consumer decoded it as a single U+FFFD and therefore changed the overall interpretation as
U+0022 is an important delimiter. Decoders of encodings that use multiple bytes for scalar
values now require that in case of an illegal byte combination, a scalar value in the
range U+0000 to U+007F, inclusive, cannot be ‚Äúmasked‚Äù. For the aforementioned sequence the
output would be U+FFFD U+0022.

<p>This is a larger issue for encodings that map anything that is an <a>ASCII byte</a> to
something that is not an <a>ASCII code point</a>, when there is no lead byte present. These
are ‚ÄúASCII-incompatible‚Äù encodings and other than <a>ISO-2022-JP</a>, <a>UTF-16BE</a>,
and <a>UTF-16LE</a>, which are unfortunately required due to deployed content, they are not
supported. (Investigation is
<a href="https://github.com/whatwg/encoding/issues/8" title="Add more labels to the replacement encoding">ongoing</a>
whether more labels of other such encodings can be mapped to the <a>replacement</a>
encoding, rather than the unknown encoding fallback.) An example attack is injecting
carefully crafted content into a resource and then encouraging the user to override the
encoding, resulting in e.g. script execution.

<p>Encoders used by URLs found in HTML and HTML's form feature can also result in slight
information loss when an encoding is used that cannot represent all scalar values. E.g.
when a resource uses the <a>windows-1252</a> encoding a server will not be able to
distinguish between an end user entering ‚Äúüí©‚Äù and ‚Äú&amp;#128169;‚Äù into a form.

<p>The problems outlined here go away when exclusively using UTF-8, which is one of the
many reasons that is now the mandatory encoding for all things.

<p class=note>See also the <a href="#browser-ui">Browser UI</a> chapter.



<h2>Conformance</h2>

<p>All diagrams, examples, and notes in this specification are
non-normative, as are all sections explicitly marked non-normative.
Everything else in this specification is normative.

<p>The key words "MUST", "MUST NOT", "REQUIRED", <!--"SHALL", "SHALL
NOT",--> "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
"OPTIONAL" in the normative parts of this document are to be
interpreted as described in RFC2119. For readability, these words do
not appear in all uppercase letters in this specification.
[[!RFC2119]]

<p>Conformance requirements phrased as algorithms or specific steps
may be implemented in any manner, so long as the end result is
equivalent. (In particular, the algorithms defined in this
specification are intended to be easy to follow, and not intended to
be performant.)

<p id="hardwareLimitations">User agents may impose
implementation-specific limits on otherwise unconstrained inputs,
e.g. to prevent denial of service attacks, to guard against running
out of memory, or to work around platform-specific limitations.



<h2>Terminology</h2>

<p>Hexadecimal numbers are prefixed with "0x".

<p>In equations, all numbers are integers, addition is represented by "+", subtraction by "&minus;",
multiplication by "&times;", division by "/", calculating the remainder of a division (also known as
modulo) by "%", logical left shifts by "&lt;&lt;", logical right shifts by ">>", bitwise AND by
"&amp;", and bitwise OR by "|". floor(<var>x</var>) is the largest integer not greater than
<var>x</var>.

<p>For logical right shifts operands must have at least twenty-one bits precision.

<p>A <dfn>byte</dfn> is a sequence of eight bits, represented as a
double-digit hexadecimal number in the range 0x00 to 0xFF, inclusive.

<p>An <dfn>ASCII byte</dfn> is a <a>byte</a> in the range 0x00 to 0x7F, inclusive.

<p>A <dfn>code point</dfn> is a Unicode code point and is represented as a
four-to-six digit hexadecimal number, typically prefixed with "U+".
In equations and <a title=index>indexes</a> code points are prefixed
with "0x". [[!UNICODE]]

<p>A <dfn>scalar value</dfn> is a <a>code point</a> that is not in the range U+D800
to U+DFFF, inclusive.

<p>An <dfn>ASCII code point</dfn> is a <a>code point</a> in the range U+0000 to
U+007F, inclusive.

<p>The <dfn>ASCII whitespace</dfn> are code points U+0009, U+000A, U+000C,
U+000D, and U+0020.

<p>The <dfn>ASCII digits</dfn> are code points in the range U+0030 to U+0039, inclusive.

<p>A <dfn>string</dfn> is a sequence of code points.

<p>Comparing two strings in an <dfn>ASCII case-insensitive</dfn> manner
means comparing them exactly, code point for code point, except that the
characters in the range U+0041 to U+005A (i.e. LATIN CAPITAL LETTER A to
LATIN CAPITAL LETTER Z), inclusive, and the corresponding characters in the range
U+0061 to U+007A (i.e. LATIN SMALL LETTER A to LATIN SMALL LETTER Z), inclusive, are
considered to also match.

<p>To <dfn>ASCII lowercase</dfn> a string, replace all code points in the range U+0041 to U+005A,
inclusive, with the corresponding code points in the range U+0061 to U+007A, inclusive.

<hr>

<p>A <dfn title=concept-token>token</dfn> is a piece of data, such as a <a>byte</a>
or <a>code point</a>.

<p>A <dfn title=concept-stream>stream</dfn> represents an ordered sequence of
<a title=concept-token>tokens</a>. <dfn>End-of-stream</dfn> is a special
<a title=concept-token>token</a> that signifies no more
<a title=concept-token>tokens</a> are in the
<a title=concept-stream>stream</a>.

<p>When a <a title=concept-token>token</a> is
<dfn title=concept-stream-read>read</dfn> from a <a title=concept-stream>stream</a>,
the first token in the stream must be returned and subsequently removed, and
<a>end-of-stream</a> must be returned otherwise.
<!-- this means read is blocking on e.g. networking activity;
     SimonSapin thinks this is fine, curse him if not -->

<p>When one or more <a title=concept-token>tokens</a> are
<dfn title=concept-stream-prepend>prepended</dfn> to a
<a title=concept-stream>stream</a>, those tokens must be inserted, in given order,
before the first token in the stream.

<p class=example>Inserting the sequence of tokens <code title>&amp;#128169;</code> in a
stream "<code title> hello world</code>", results in a stream
"<code title>&amp;#128169; hello world</code>". The next token to be read would be
<code title>&amp;</code>. <!-- üí© -->

<p>When one or more <a title=concept-token>tokens</a> are
<dfn title=concept-stream-push>pushed</dfn> to a <a title=concept-stream>stream</a>,
those tokens must be inserted, in given order, after the last token in the stream.



<h2>Encodings</h2>

<p>An <dfn data-export>encoding-xxx</dfn> defines a mapping from a <a>scalar value</a> sequence to
a <a>byte</a> sequence (and vice versa). Each <a>encoding</a> has a
<dfn data-export data-dfn-for=encoding>name</dfn>, and one or more
<dfn data-export data-dfn-for=encoding data-lt=label title=label>labels</dfn>.


<h3>Encoders and decoders</h3>

<p>Each <a>encoding</a> has an associated <dfn>decoder</dfn> and most of them have an
associated <dfn>encoder</dfn>. Each <a>decoder</a> and <a>encoder</a> have a
<dfn>handler</dfn> algorithm. A <a>handler</a> algorithm takes an input
<a title=concept-stream>stream</a> and a <a title=concept-token>token</a>, and returns
<dfn>finished</dfn>, one or more <a title=concept-token>tokens</a>, <dfn>error</dfn>
optionally with a <a>code point</a>, or <dfn>continue</dfn>.

<p class="note no-backref">The <a>replacement</a>, <a>UTF-16BE</a>, and
<a>UTF-16LE</a> <a title=encoding>encodings</a> have no <a>encoder</a>.

<p>An <dfn>error mode</dfn> as used below is "<code title>replacement</code>" (default) or
"<code>fatal</code>" for a <a>decoder</a> and "<code>fatal</code>" (default) or
"<code>html</code>" for an <a>encoder</a>.

<p class=note>An XML processor would set <a>error mode</a> to "<code>fatal</code>".
[[XML]]

<p class=note>"<code>html</code>" exists as <a>error mode</a> due to URLs and HTML forms
requiring a non-terminating legacy <a>encoder</a>. The "<code>html</code>"
<a>error mode</a> causes a sequence to be emitted that cannot be distinguished from
legitimate input and can therefore lead to silent data loss. Developers are strongly
encouraged to use the <a>UTF-8</a> <a>encoding</a> to prevent this from
happening.
[[URL]]
[[HTML]]

<p>To <dfn title=concept-encoding-run>run</dfn> an <a>encoding</a>'s
<a>decoder</a> or <a>encoder</a> <var>encoderDecoder</var> with input
<a title=concept-stream>stream</a> <var>input</var>, output
<a title=concept-stream>stream</a> <var>output</var>, and optional
<a>error mode</a> <var>mode</var>, run these steps:

<ol>
 <li><p>If <var>mode</var> is not given, set it to "<code title>replacement</code>", if
 <var>encoderDecoder</var> is a <a>decoder</a>, and "<code>fatal</code>" otherwise.

 <li><p>Let <var>encoderDecoderInstance</var> be a new <var>encoderDecoder</var>.

 <li>
  <p>While true:

  <ol>
   <li><p>Let <var>result</var> be the result of
   <a title=concept-encoding-process>processing</a> the result of
   <a title=concept-stream-read>reading</a> from <var>input</var> for
   <var>encoderDecoderInstance</var>, <var>input</var>, <var>output</var>, and
   <var>mode</var>.

   <li><p>If <var>result</var> is not <a>continue</a>, return <var>result</var>.

   <li><p>Otherwise, do nothing.
  </ol>
</ol>

<p>To <dfn title=concept-encoding-process>process</dfn> a
<a title=concept-token>token</a> <var>token</var> for an <a>encoding</a>'s
<a>encoder</a> or <a>decoder</a> instance <var>encoderDecoderInstance</var>,
<a title=concept-stream>stream</a> <var>input</var>, output
<a title=concept-stream>stream</a> <var>output</var>, and optional
<a>error mode</a> <var>mode</var>, run these steps:

<ol>
 <li><p>If <var>mode</var> is not given, set it to "<code title>replacement</code>", if
 <var>encoderDecoderInstance</var> is a <a>decoder</a> instance, and "<code>fatal</code>"
 otherwise.

 <li><p>Let <var>result</var> be the result of running <var>encoderDecoderInstance</var>'s
 <a>handler</a> on <var>input</var> and <var>token</var>.

 <li><p>If <var>result</var> is <a>continue</a> or <a>finished</a>, return
 <var>result</var>.

 <li><p>Otherwise, if <var>result</var> is one or more
 <a title=concept-token>tokens</a>, <a title=concept-stream-push>push</a>
 <var>result</var> to <var>output</var>.

 <li>
  <p>Otherwise, if <var>result</var> is <a>error</a>, switch on <var>mode</var> and
  run the associated steps:

  <dl class=switch>
   <dt>"<code title>replacement</code>"
   <dd><a title=concept-stream-push>Push</a> U+FFFD to <var>output</var>.
   <dt>"<code>html</code>"
   <dd><a title=concept-stream-prepend>Prepend</a> U+0026, U+0023, followed by the
   shortest sequence of <a>ASCII digits</a> representing <var>result</var>'s
   <a>code point</a> in base ten, followed by U+003B to <var>input</var>.
   <!-- &# ... ; -->
   <dt>"<code>fatal</code>"
   <dd>Return <a>error</a>.
  </dl>

 <li>Return <a>continue</a>.
</ol>


<h3>Names and labels</h3>

<p>The table below lists all <a title=encoding>encodings</a>
and their <a title=label>labels</a> user agents must support.
User agents must not support any other <a title=encoding>encodings</a>
or <a title=label>labels</a>.

<p>Authors must use the <a>UTF-8</a> <a>encoding</a> and must use the
<a>ASCII case-insensitive</a> "<code title>utf-8</code>" <a>label</a> to
identify it.

<p>New protocols and formats, as well as existing formats deployed in new contexts, must
use the <a>UTF-8</a> <a>encoding</a> exclusively. If these protocols and
formats need to expose the <a>encoding</a>'s <a>name</a> or
<a>label</a>, they must expose it as "<code title>utf-8</code>".

<p>To <dfn export abstract-op lt="get an encoding|getting an encoding">get an encoding</dfn> from a string
<var>label</var>, run these steps:

<ol>
 <li><p>Remove any leading and trailing <a>ASCII whitespace</a> from
 <var>label</var>.

 <li><p>If <var>label</var> is an <a>ASCII case-insensitive</a>
 match for any of the <a title=label>labels</a> listed in the table
 below, return the corresponding <a>encoding</a>, and failure otherwise.
</ol>

<p class="note no-backref">This is a much simpler and more restrictive algorithm of
mapping <a title=label>labels</a> to <a title=encoding>encodings</a> than
<a href="http://www.unicode.org/reports/tr22/tr22-7.html#Charset_Alias_Matching">section 1.4 of Unicode Technical Standard #22</a>
prescribes, as that is found to be necessary to be compatible with deployed content.

<table>
 <thead>
  <tr>
   <th><a>Name</a>
   <th><a title=label>Labels</a>
 <tbody>
  <tr><th colspan=2><a href=#the-encoding>The Encoding</a>
  <tr>
   <td rowspan=3><a>UTF-8</a>
   <td>"<code title>unicode-1-1-utf-8</code>"
  <tr><td>"<code title>utf-8</code>"
  <tr><td>"<code title>utf8</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-single-byte-encodings>Legacy single-byte encodings</a>
  <tr>
   <td rowspan=4><a>IBM866</a>
   <td>"<code title>866</code>"
  <tr><td>"<code title>cp866</code>"
  <tr><td>"<code title>csibm866</code>"
  <tr><td>"<code title>ibm866</code>"
  <tr>
   <td rowspan=9><a>ISO-8859-2</a>
   <td>"<code title>csisolatin2</code>"
  <tr><td>"<code title>iso-8859-2</code>"
  <tr><td>"<code title>iso-ir-101</code>"
  <tr><td>"<code title>iso8859-2</code>"
  <tr><td>"<code title>iso88592</code>"
  <tr><td>"<code title>iso_8859-2</code>"
  <tr><td>"<code title>iso_8859-2:1987</code>"
  <tr><td>"<code title>l2</code>"
  <tr><td>"<code title>latin2</code>"
  <tr>
   <td rowspan=9><a>ISO-8859-3</a>
   <td>"<code title>csisolatin3</code>"
  <tr><td>"<code title>iso-8859-3</code>"
  <tr><td>"<code title>iso-ir-109</code>"
  <tr><td>"<code title>iso8859-3</code>"
  <tr><td>"<code title>iso88593</code>"
  <tr><td>"<code title>iso_8859-3</code>"
  <tr><td>"<code title>iso_8859-3:1988</code>"
  <tr><td>"<code title>l3</code>"
  <tr><td>"<code title>latin3</code>"
  <tr>
   <td rowspan=9><a>ISO-8859-4</a>
   <td>"<code title>csisolatin4</code>"
  <tr><td>"<code title>iso-8859-4</code>"
  <tr><td>"<code title>iso-ir-110</code>"
  <tr><td>"<code title>iso8859-4</code>"
  <tr><td>"<code title>iso88594</code>"
  <tr><td>"<code title>iso_8859-4</code>"
  <tr><td>"<code title>iso_8859-4:1988</code>"
  <tr><td>"<code title>l4</code>"
  <tr><td>"<code title>latin4</code>"
  <tr>
   <td rowspan=8><a>ISO-8859-5</a>
   <td>"<code title>csisolatincyrillic</code>"
  <tr><td>"<code title>cyrillic</code>"
  <tr><td>"<code title>iso-8859-5</code>"
  <tr><td>"<code title>iso-ir-144</code>"
  <tr><td>"<code title>iso8859-5</code>"
  <tr><td>"<code title>iso88595</code>"
  <tr><td>"<code title>iso_8859-5</code>"
  <tr><td>"<code title>iso_8859-5:1988</code>"
  <tr>
   <td rowspan=14><a>ISO-8859-6</a>
   <td>"<code title>arabic</code>"
  <tr><td>"<code title>asmo-708</code>"
  <tr><td>"<code title>csiso88596e</code>"
  <tr><td>"<code title>csiso88596i</code>"
  <tr><td>"<code title>csisolatinarabic</code>"
  <tr><td>"<code title>ecma-114</code>"
  <tr><td>"<code title>iso-8859-6</code>"
  <tr><td>"<code title>iso-8859-6-e</code>"
  <tr><td>"<code title>iso-8859-6-i</code>"
  <tr><td>"<code title>iso-ir-127</code>"
  <tr><td>"<code title>iso8859-6</code>"
  <tr><td>"<code title>iso88596</code>"
  <tr><td>"<code title>iso_8859-6</code>"
  <tr><td>"<code title>iso_8859-6:1987</code>"
  <tr>
   <td rowspan=12><a>ISO-8859-7</a>
   <td>"<code title>csisolatingreek</code>"
  <tr><td>"<code title>ecma-118</code>"
  <tr><td>"<code title>elot_928</code>"
  <tr><td>"<code title>greek</code>"
  <tr><td>"<code title>greek8</code>"
  <tr><td>"<code title>iso-8859-7</code>"
  <tr><td>"<code title>iso-ir-126</code>"
  <tr><td>"<code title>iso8859-7</code>"
  <tr><td>"<code title>iso88597</code>"
  <tr><td>"<code title>iso_8859-7</code>"
  <tr><td>"<code title>iso_8859-7:1987</code>"
  <tr><td>"<code title>sun_eu_greek</code>"
  <tr>
   <td rowspan=11><a>ISO-8859-8</a>
   <td>"<code title>csiso88598e</code>"
  <tr><td>"<code title>csisolatinhebrew</code>"
  <tr><td>"<code title>hebrew</code>"
  <tr><td>"<code title>iso-8859-8</code>"
  <tr><td>"<code title>iso-8859-8-e</code>"
  <tr><td>"<code title>iso-ir-138</code>"
  <tr><td>"<code title>iso8859-8</code>"
  <tr><td>"<code title>iso88598</code>"
  <tr><td>"<code title>iso_8859-8</code>"
  <tr><td>"<code title>iso_8859-8:1988</code>"
  <tr><td>"<code title>visual</code>"
  <tr>
   <td rowspan=3><a>ISO-8859-8-I</a>
   <td>"<code title>csiso88598i</code>"
  <tr><td>"<code title>iso-8859-8-i</code>"
  <tr><td>"<code title>logical</code>"
  <tr>
   <td rowspan=7><a>ISO-8859-10</a>
   <td>"<code title>csisolatin6</code>"
  <tr><td>"<code title>iso-8859-10</code>"
  <tr><td>"<code title>iso-ir-157</code>"
  <tr><td>"<code title>iso8859-10</code>"
  <tr><td>"<code title>iso885910</code>"
  <tr><td>"<code title>l6</code>"
  <tr><td>"<code title>latin6</code>"
  <tr>
   <td rowspan=3><a>ISO-8859-13</a>
   <td>"<code title>iso-8859-13</code>"
  <tr><td>"<code title>iso8859-13</code>"
  <tr><td>"<code title>iso885913</code>"
  <tr>
   <td rowspan=3><a>ISO-8859-14</a>
   <td>"<code title>iso-8859-14</code>"
  <tr><td>"<code title>iso8859-14</code>"
  <tr><td>"<code title>iso885914</code>"
  <tr>
   <td rowspan=6><a>ISO-8859-15</a>
   <td>"<code title>csisolatin9</code>"
  <tr><td>"<code title>iso-8859-15</code>"
  <tr><td>"<code title>iso8859-15</code>"
  <tr><td>"<code title>iso885915</code>"
  <tr><td>"<code title>iso_8859-15</code>"
  <tr><td>"<code title>l9</code>"
  <tr>
   <td><a>ISO-8859-16</a>
   <td>"<code title>iso-8859-16</code>"
  <tr>
   <td rowspan=5><a>KOI8-R</a>
   <td>"<code title>cskoi8r</code>"
  <tr><td>"<code title>koi</code>"
  <tr><td>"<code title>koi8</code>"
  <tr><td>"<code title>koi8-r</code>"
  <tr><td>"<code title>koi8_r</code>"
  <tr>
   <td rowspan=2><a>KOI8-U</a>
   <td>"<code title>koi8-ru</code>"
  <tr><td>"<code title>koi8-u</code>"
  <tr>
   <td rowspan=4><a>macintosh</a>
   <td>"<code title>csmacintosh</code>"
  <tr><td>"<code title>mac</code>"
  <tr><td>"<code title>macintosh</code>"
  <tr><td>"<code title>x-mac-roman</code>"
  <tr>
   <td rowspan=6><a>windows-874</a>
   <td>"<code title>dos-874</code>"
  <tr><td>"<code title>iso-8859-11</code>"
  <tr><td>"<code title>iso8859-11</code>"
  <tr><td>"<code title>iso885911</code>"
  <tr><td>"<code title>tis-620</code>"
  <tr><td>"<code title>windows-874</code>"
  <tr>
   <td rowspan=3><a>windows-1250</a>
   <td>"<code title>cp1250</code>"
  <tr><td>"<code title>windows-1250</code>"
  <tr><td>"<code title>x-cp1250</code>"
  <tr>
   <td rowspan=3><a>windows-1251</a>
   <td>"<code title>cp1251</code>"
  <tr><td>"<code title>windows-1251</code>"
  <tr><td>"<code title>x-cp1251</code>"
  <tr>
   <td rowspan=17><a>windows-1252</a>
   <td>"<code title>ansi_x3.4-1968</code>"
  <tr><td>"<code title>ascii</code>"
  <tr><td>"<code title>cp1252</code>"
  <tr><td>"<code title>cp819</code>"
  <tr><td>"<code title>csisolatin1</code>"
  <tr><td>"<code title>ibm819</code>"
  <tr><td>"<code title>iso-8859-1</code>"
  <tr><td>"<code title>iso-ir-100</code>"
  <tr><td>"<code title>iso8859-1</code>"
  <tr><td>"<code title>iso88591</code>"
  <tr><td>"<code title>iso_8859-1</code>"
  <tr><td>"<code title>iso_8859-1:1987</code>"
  <tr><td>"<code title>l1</code>"
  <tr><td>"<code title>latin1</code>"
  <tr><td>"<code title>us-ascii</code>"
  <tr><td>"<code title>windows-1252</code>"
  <tr><td>"<code title>x-cp1252</code>"
  <tr>
   <td rowspan=3><a>windows-1253</a>
   <td>"<code title>cp1253</code>"
  <tr><td>"<code title>windows-1253</code>"
  <tr><td>"<code title>x-cp1253</code>"
  <tr>
   <td rowspan=12><a>windows-1254</a>
   <td>"<code title>cp1254</code>"
  <tr><td>"<code title>csisolatin5</code>"
  <tr><td>"<code title>iso-8859-9</code>"
  <tr><td>"<code title>iso-ir-148</code>"
  <tr><td>"<code title>iso8859-9</code>"
  <tr><td>"<code title>iso88599</code>"
  <tr><td>"<code title>iso_8859-9</code>"
  <tr><td>"<code title>iso_8859-9:1989</code>"
  <tr><td>"<code title>l5</code>"
  <tr><td>"<code title>latin5</code>"
  <tr><td>"<code title>windows-1254</code>"
  <tr><td>"<code title>x-cp1254</code>"
  <tr>
   <td rowspan=3><a>windows-1255</a>
   <td>"<code title>cp1255</code>"
  <tr><td>"<code title>windows-1255</code>"
  <tr><td>"<code title>x-cp1255</code>"
  <tr>
   <td rowspan=3><a>windows-1256</a>
   <td>"<code title>cp1256</code>"
  <tr><td>"<code title>windows-1256</code>"
  <tr><td>"<code title>x-cp1256</code>"
  <tr>
   <td rowspan=3><a>windows-1257</a>
   <td>"<code title>cp1257</code>"
  <tr><td>"<code title>windows-1257</code>"
  <tr><td>"<code title>x-cp1257</code>"
  <tr>
   <td rowspan=3><a>windows-1258</a>
   <td>"<code title>cp1258</code>"
  <tr><td>"<code title>windows-1258</code>"
  <tr><td>"<code title>x-cp1258</code>"
  <tr>
   <td rowspan=2><a>x-mac-cyrillic</a>
   <td>"<code title>x-mac-cyrillic</code>"
  <tr><td>"<code title>x-mac-ukrainian</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-chinese-(simplified)-encodings>Legacy multi-byte Chinese (simplified) encodings</a>
  <tr>
   <td rowspan=9><a>GBK</a>
   <td>"<code title>chinese</code>"
  <tr><td>"<code title>csgb2312</code>"
  <tr><td>"<code title>csiso58gb231280</code>"
  <tr><td>"<code title>gb2312</code>"
  <tr><td>"<code title>gb_2312</code>"
  <tr><td>"<code title>gb_2312-80</code>"
  <tr><td>"<code title>gbk</code>"
  <tr><td>"<code title>iso-ir-58</code>"
  <tr><td>"<code title>x-gbk</code>"
  <tr>
   <td><a>gb18030</a>
   <td>"<code title>gb18030</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-chinese-(traditional)-encodings>Legacy multi-byte Chinese (traditional) encodings</a>
  <tr>
   <td rowspan=5><a>Big5</a>
   <td>"<code title>big5</code>"
  <tr><td>"<code title>big5-hkscs</code>"
  <tr><td>"<code title>cn-big5</code>"
  <tr><td>"<code title>csbig5</code>"
  <tr><td>"<code title>x-x-big5</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-japanese-encodings>Legacy multi-byte Japanese encodings</a>
  <tr>
   <td rowspan=3><a>EUC-JP</a>
   <td>"<code title>cseucpkdfmtjapanese</code>"
  <tr><td>"<code title>euc-jp</code>"
  <tr><td>"<code title>x-euc-jp</code>"
  <tr>
   <td rowspan=2><a>ISO-2022-JP</a>
   <td>"<code title>csiso2022jp</code>"
  <tr><td>"<code title>iso-2022-jp</code>"
  <tr>
   <td rowspan=8><a>Shift_JIS</a>
   <td>"<code title>csshiftjis</code>"
  <tr><td>"<code title>ms932</code>"
  <tr><td>"<code title>ms_kanji</code>"
  <tr><td>"<code title>shift-jis</code>"
  <tr><td>"<code title>shift_jis</code>"
  <tr><td>"<code title>sjis</code>"
  <tr><td>"<code title>windows-31j</code>"
  <tr><td>"<code title>x-sjis</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-multi-byte-korean-encodings>Legacy multi-byte Korean encodings</a>
  <tr>
   <td rowspan=10><a>EUC-KR</a>
   <td>"<code title>cseuckr</code>"
  <tr><td>"<code title>csksc56011987</code>"
  <tr><td>"<code title>euc-kr</code>"
  <tr><td>"<code title>iso-ir-149</code>"
  <tr><td>"<code title>korean</code>"
  <tr><td>"<code title>ks_c_5601-1987</code>"
  <tr><td>"<code title>ks_c_5601-1989</code>"
  <tr><td>"<code title>ksc5601</code>"
  <tr><td>"<code title>ksc_5601</code>"
  <tr><td>"<code title>windows-949</code>"
 <tbody>
  <tr><th colspan=2><a href=#legacy-miscellaneous-encodings>Legacy miscellaneous encodings</a>
  <tr>
   <td rowspan=5><a>replacement</a>
   <td>"<code title>csiso2022kr</code>"
  <tr><td>"<code title>hz-gb-2312</code>"
  <tr><td>"<code title>iso-2022-cn</code>"
  <tr><td>"<code title>iso-2022-cn-ext</code>"
  <tr><td>"<code title>iso-2022-kr</code>"
  <tr>
   <td><a>UTF-16BE</a>
   <td>"<code title>utf-16be</code>"
  <tr>
   <td rowspan=2><a>UTF-16LE</a>
   <td>"<code title>utf-16</code>"
  <tr><td>"<code title>utf-16le</code>"
  <tr>
   <td><a>x-user-defined</a>
   <td>"<code title>x-user-defined</code>"
</table>

<p class=note>All <a title=encoding>encodings</a> and their
<a title=label>labels</a> are also available as non-normative
<a href=encodings.json>encodings.json</a> resource.


<h3>Output encodings</h3>

<p>To <dfn data-export>get an output encoding</dfn> from an <a>encoding</a>
<var>encoding</var>, run these steps:</p>

<ol>
 <li><p>If <var>encoding</var> is <a>replacement</a>, <a>UTF-16BE</a>, or
 <a>UTF-16LE</a>, return <a>UTF-8</a>.

 <li><p>Return <var>encoding</var>.
</ol>

<p class="note">The <a>get an output encoding</a> algorithm is useful for URL parsing HTML
form submission, which both need exactly this.



<h2>Indexes</h2>

<p>Most legacy <a title=encoding>encodings</a> make use of
an <dfn>index</dfn>. An <a>index</a> is an ordered list of
pointers and corresponding code points. Within an <a>index</a>
pointers are unique and code points can be duplicated.

<p class="note no-backref">An efficient implementation likely has two
<a title=index>indexes</a> per <a>encoding</a>. One optimized for its
<a>decoder</a> and one for its <a>encoder</a>.

<p>To find the pointers and their corresponding code points in an <a>index</a>,
let <var>lines</var> be the result of splitting the resource's contents on U+000A.
Then remove each item in <var>lines</var> that is the empty string or starts with U+0023.
Then the pointers and their corresponding code points are found by splitting each item in <var>lines</var> on U+0009.
The first subitem is the pointer (as a decimal number) and the second is the corresponding code point (as a hexadecimal number).
Other subitems are not relevant.

<p class="note no-backref">To signify changes an <a>index</a> includes an
<i title>Identifier</i> and a <i title>Date</i>. If an <i title>Identifier</i> has
changed, so has the <a>index</a>.

<p>The <dfn>index code point</dfn> for <var>pointer</var> in
<var>index</var> is the code point corresponding to
<var>pointer</var> in <var>index</var>, or null if
<var>pointer</var> is not in <var>index</var>.

<p>The <dfn>index pointer</dfn> for <var>code point</var> in
<var>index</var> is the <em>first</em> pointer corresponding to
<var>code point</var> in <var>index</var>, or null if
<var>code point</var> is not in <var>index</var>.

<p>These are the <a title=index>indexes</a> defined by this
specification, excluding <a>index single-byte</a>, which have their own table:

<table>
 <tr><th colspan=2><a>Index</a><th>Notes
 <tr>
  <td><dfn>index Big5</dfn>
  <td><a href=index-big5.txt>index-big5.txt</a>
  <td>This matches the Big5 standard in combination with the
  Hong Kong Supplementary Character Set and other common extensions.
 <tr>
  <td><dfn>index EUC-KR</dfn>
  <td><a href=index-euc-kr.txt>index-euc-kr.txt</a>
  <td>This matches the KS X 1001 standard and the Unified Hangul Code, more
  commonly known together as Windows Codepage 949.
 <tr>
  <td><dfn>index gb18030</dfn>
  <td><a href=index-gb18030.txt>index-gb18030.txt</a>
  <td>This matches the GB18030-2005 standard for code points encoded as two bytes, except for
  0xA3 0xA0 which maps to U+3000 to be compatible with deployed content.
  <!-- https://bugzilla.mozilla.org/show_bug.cgi?id=131837
       https://bugs.webkit.org/show_bug.cgi?id=17014
       https://www.w3.org/Bugs/Public/show_bug.cgi?id=25396
       https://github.com/whatwg/encoding/issues/17 -->
 <tr>
  <td><dfn>index gb18030 ranges</dfn>
  <td><a href=index-gb18030-ranges.txt>index-gb18030-ranges.txt</a>
  <td>This <a>index</a> works different from all others. Listing all code points would result
  in over a million items whereas they can be represented neatly in 207 ranges combined with trivial
  limit checks. It therefore only superficially matches the GB18030-2005 standard for code points
  encoded as four bytes. See also <a>index gb18030 ranges code point</a> and
  <a>index gb18030 ranges pointer</a> below.
 <tr>
  <td><dfn>index jis0208</dfn>
  <td><a href=index-jis0208.txt>index-jis0208.txt</a>
  <td>This is the JIS X 0208 standard including formerly proprietary
  extensions from IBM and NEC.
  <!-- NEC = Nippon Electronics Corporation -->
 <tr>
  <td><dfn>index jis0212</dfn>
  <td><a href=index-jis0212.txt>index-jis0212.txt</a>
  <td>This is the JIS X 0212 standard. It is only used by the <a>EUC-JP decoder</a>
  due to lack of widespread support elsewhere.
  <!--
   No JIX X 0212 euc-jp encoder support:
     https://bugzilla.mozilla.org/show_bug.cgi?id=600715
     https://code.google.com/p/chromium/issues/detail?id=78847

   No JIX X 0212 iso-2022-jp support:
     https://www.w3.org/Bugs/Public/show_bug.cgi?id=26885
  -->
</table>

<p>The <dfn>index gb18030 ranges code point</dfn> for <var>pointer</var> is
the return value of these steps:

<ol>
 <li><p>If <var>pointer</var> is greater than 39419 and less than
 189000, or <var>pointer</var> is greater than 1237575, return null.

 <li><p>If <var>pointer</var> is 7457, return code point U+E7C7.
 <!-- 7457 is 0x81 0x35 0xF4 0x37 -->

 <li><p>Let <var>offset</var> be the last pointer in
 <a>index gb18030 ranges</a> that is equal to or less than
 <var>pointer</var> and let <var>code point offset</var> be its
 corresponding code point.

 <li><p>Return a code point whose value is
 <var>code point offset</var> + <var>pointer</var> &minus; <var>offset</var>.
</ol>

<p>The <dfn>index gb18030 ranges pointer</dfn> for <var>code point</var> is
the return value of these steps:

<ol>
 <li><p>If <var>code point</var> is U+E7C7, return pointer 7457.

 <li><p>Let <var>offset</var> be the last code point in
 <a>index gb18030 ranges</a> that is equal to or less than
 <var>code point</var> and let <var>pointer offset</var> be its
 corresponding pointer.

 <li><p>Return a pointer whose value is
 <var>pointer offset</var> + <var>code point</var> &minus; <var>offset</var>.
</ol>

<p>The <dfn>index Shift_JIS pointer</dfn> for <var>code point</var> is the return value of these
steps:

<ol>
 <li><p>Let <var>index</var> be <a>index jis0208</a> excluding all pointers in
 the range 8272 to 8835, inclusive.
 <!-- selected NEC duplicates from IBM extensions later in the index; need to use IBM
      extensions when going back to bytes -->

 <li><p>Return the <a>index pointer</a> for <var>code point</var> in
 <var>index</var>.
</ol>

<p>The <dfn>index Big5 pointer</dfn> for <var>code point</var> is the return value of
these steps:

<ol>
 <li>
  <p>Let <var>index</var> be <a>index Big5</a> excluding all pointers less than
  (0xA1 - 0x81) &times; 157.

  <p class=note>Avoid returning Hong Kong Supplementary Character Set extensions literally.

 <li>
  <p>If <var>code point</var> is U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345,
  return the <em>last</em> pointer corresponding to <var>code point</var> in
  <var>index</var>.
  <!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=27878 -->

  <p class=note>There are other duplicate code points, but for those the <em>first</em> pointer is
  to be used.

 <li><p>Return the <a>index pointer</a> for <var>code point</var> in
 <var>index</var>.
</ol>

<hr>

<p class="note no-backref">All <a title=index>indexes</a> are also available as
non-normative <a href=indexes.json>indexes.json</a> resource.
(<a>index gb18030 ranges</a> has a slightly different format here, to be able
to represent ranges.)



<h2>Specification hooks</h2>

<p class=note>The algorithms <a>decode</a>, <a>UTF-8 decode</a>,
<a>UTF-8 decode without BOM</a>, <a>UTF-8 decode without BOM or fail</a>,
<a>encode</a>, and <a>UTF-8 encode</a> are intended for usage by other specifications.
<a>UTF-8 decode</a> is to be used by new formats. The
<a>get an encoding</a> algorithm can be used first to turn a
<a>label</a> into an <a>encoding</a>.

<p>To <dfn data-export>decode</dfn> a byte stream <var>stream</var> using
fallback encoding <var>encoding</var>, run these steps:

<ol>
 <li><p>Let <var>buffer</var> be an empty byte sequence.

 <LI><p>Let <var>BOM seen flag</var> be unset.

 <li><p><a title=concept-stream-read>Read</a> bytes from <var>stream</var>
 into <var>buffer</var> until either <var>buffer</var> contains three bytes or
 <a title=concept-stream-read>read</a> returns <a>end-of-stream</a>.

 <li>
  <p>For each of the rows in the table below, starting with the first
  one and going down, if the first bytes of <var>buffer</var> match
  all the bytes given in the first column, then set <var>encoding</var>
  to the <a>encoding</a> given in the cell in the second column of
  that row and set <var>BOM seen flag</var>.

  <table>
   <tr><th>Byte order mark<th>Encoding
   <tr><td>0xEF 0xBB 0xBF<td><a>UTF-8</a>
   <tr><td>0xFE 0xFF<td><a>UTF-16BE</a>
   <tr><td>0xFF 0xFE<td><a>UTF-16LE</a>
  </table>

  <p class=note>For compatibility with deployed content, the byte order mark (also known as BOM) is
  more authoritative than anything else. In a context where HTTP is used this is in violation of the
  semantics of the `<code>Content-Type</code>` header.

 <li><p>If <var>BOM seen flag</var> is unset
 <a title=concept-stream-prepend>prepend</a> <var>buffer</var> to <var>stream</var>.

 <li><p>Otherwise, if <var>BOM seen flag</var> is set, <var>encoding</var> is not
 <a>UTF-8</a>, and <var>buffer</var> contains three bytes,
 <a title=concept-stream-prepend>prepend</a> the last byte of <var>buffer</var> to
 <var>stream</var>.

 <li><p>Let <var>output</var> be a code point <a title=concept-stream>stream</a>.

 <li><p><a title=concept-encoding-run>Run</a> <var>encoding</var>'s
 <a>decoder</a> with <var>stream</var> and <var>output</var>.

 <li><p>Return <var>output</var>.
</ol>

<p>To <dfn data-export>UTF-8 decode</dfn> a byte stream <var>stream</var>, run
these steps:

<ol>
 <li><p>Let <var>buffer</var> be an empty byte sequence.

 <li><p><a title=concept-stream-read>Read</a> three bytes from <var>stream</var>
 into <var>buffer</var>.

 <li><p>If <var>buffer</var> does not match 0xEF 0xBB 0xBF,
 <a title=concept-stream-prepend>prepend</a> <var>buffer</var> to <var>stream</var>.

 <li><p>Let <var>output</var> be a code point <a title=concept-stream>stream</a>.

 <li><p><a title=concept-encoding-run>Run</a> <a>UTF-8</a>'s
 <a>decoder</a> with <var>stream</var> and <var>output</var>.

 <li><p>Return <var>output</var>.
</ol>

<p>To <dfn data-export>UTF-8 decode without BOM</dfn> a byte stream <var>stream</var>, run these
steps:

<ol>
 <li><p>Let <var>output</var> be a code point <a title=concept-stream>stream</a>.

 <li><p><a title=concept-encoding-run>Run</a> <a>UTF-8</a>'s
 <a>decoder</a> with <var>stream</var> and <var>output</var>.

 <li><p>Return <var>output</var>.
</ol>

<p>To <dfn data-export>UTF-8 decode without BOM or fail</dfn> a byte stream <var>stream</var>, run these steps:

<ol>
 <li><p>Let <var>output</var> be a code point stream.

 <li><p>Let <var>potentialError</var> be the result of <a title=concept-encoding-run>run</a>
 <a>UTF-8</a>'s <a>decoder</a> with <var>stream</var>, <var>output</var>, and
 "<code>fatal</code>".

 <li><p>If <var>potentialError</var> is <a>error</a>, return failure.

 <li><p>Return <var>output</var>.</p></li>
</ol>

<hr>

<p>To <dfn data-export>encode</dfn> a code point stream <var>stream</var> using
encoding <var>encoding</var>, run these steps:

<ol>
 <li><p>Assert: <var>encoding</var> is not <a>replacement</a>, <a>UTF-16BE</a> or
 <a>UTF-16LE</a>.

 <li><p>Let <var>output</var> be a byte <a title=concept-stream>stream</a>.

 <li><p><a title=concept-encoding-run>Run</a> <var>encoding</var>'s
 <a>encoder</a> with <var>stream</var>, <var>output</var>, and "<code>html</code>".

 <li><p>Return <var>output</var>.
</ol>

<p class="note no-backref">This is mostly a legacy hook for URLs and HTML forms. Layering
<a>UTF-8 encode</a> on top is safe as it never triggers
<a title=error>errors</a>.
[[URL]]
[[HTML]]

<p>To <dfn data-export>UTF-8 encode</dfn> a code point stream <var>stream</var>,
return the result of <a title=encode>encoding</a>
<var>stream</var> using encoding <a>UTF-8</a>.



<h2>API</h2>

<!-- https://wiki.whatwg.org/wiki/StringEncoding  -->

<p>This section uses terminology from the DOM and Web IDL.
Non-browser user agents are not required to support this API.

[[!DOM]]
[[!WEBIDL]]

<div class=example>
 <p>The following example uses the <code>TextEncoder</code> object to encode
 an array of strings into an
 <code title>ArrayBuffer</code>. The result is a
 <code title>Uint8Array</code> containing the number
 of strings (as a <code title>Uint32Array</code>),
 followed by the length of the first string (as a
 <code title>Uint32Array</code>), the
 <a>UTF-8</a> encoded string data, the length of the second string (as
 a <code title>Uint32Array</code>), the string data,
 and so on.
 <pre><code>function encodeArrayOfStrings(strings) {
  var encoder, encoded, len, bytes, view, offset;

  encoder = new TextEncoder();
  encoded = [];

  len = Uint32Array.BYTES_PER_ELEMENT;
  for (var i = 0; i < strings.length; i++) {
    len += Uint32Array.BYTES_PER_ELEMENT;
    encoded[i] = encoder.encode(strings[i]);
    len += encoded[i].byteLength;
  }

  bytes = new Uint8Array(len);
  view = new DataView(bytes.buffer);
  offset = 0;

  view.setUint32(offset, strings.length);
  offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var i = 0; i < encoded.length; i += 1) {
    len = encoded[i].byteLength;
    view.setUint32(offset, len);
    offset += Uint32Array.BYTES_PER_ELEMENT;
    bytes.set(encoded[i], offset);
    offset += len;
  }
  return bytes.buffer;
}</code></pre>

 <p>The following example decodes an <code title>ArrayBuffer</code> containing data encoded in the
 format produced by the previous example, or an equivalent algorithm for encodings other than
 <a>UTF-8</a>, back into an array of strings.

 <pre><code>function decodeArrayOfStrings(buffer, encoding) {
  var decoder, view, offset, num_strings, strings, len;

  decoder = new TextDecoder(encoding);
  view = new DataView(buffer);
  offset = 0;
  strings = [];

  num_strings = view.getUint32(offset);
  offset += Uint32Array.BYTES_PER_ELEMENT;
  for (var i = 0; i < num_strings; i++) {
    len = view.getUint32(offset);
    offset += Uint32Array.BYTES_PER_ELEMENT;
    strings[i] = decoder.decode(
      new DataView(view.buffer, offset, len));
    offset += len;
  }
  return strings;
}</code></pre>
</div>


<h3>Interface {{TextDecoder}}</h3>

<pre class=idl>
dictionary TextDecoderOptions {
  boolean fatal = false;
  boolean ignoreBOM = false;
};

dictionary TextDecodeOptions {
  boolean stream = false;
};

[Constructor(optional DOMString label = "utf-8", optional TextDecoderOptions options),
 Exposed=Window,Worker]
interface TextDecoder {
  readonly attribute DOMString encoding;
  readonly attribute boolean fatal;
  readonly attribute boolean ignoreBOM;
  USVString decode(optional BufferSource input, optional TextDecodeOptions options);
};</pre>

<p>A {{TextDecoder}} object has an associated <b>encoding</b>, <b>decoder</b>,
<b>stream</b>, <b>ignore BOM flag</b> (initially unset),
<b>BOM seen flag</b> (initially unset),
<b>error mode</b> (initially "<code title>replacement</code>"), and
<b>do not flush flag</b> (initially unset).

<p>A {{TextDecoder}} object also has an associated
<dfn abstract-op for=TextDecoder>serialize stream</dfn> algorithm, that given a
<a title=concept-stream>stream</a> <var>stream</var>, runs these steps:

<ol>
 <li><p>Let <var>output</var> be the empty <a>string</a>.

 <li>
  <p>While true:

  <ol>
   <li><p>Let <var>token</var> be the result of
   <a title=concept-stream-read>reading</a> from <var>stream</var>.

   <li>
    <p>If <b>encoding</b> is <a>UTF-8</a>, <a>UTF-16BE</a>, or <a>UTF-16LE</a>,
    and <b>ignore BOM flag</b> and <b>BOM seen flag</b> are unset, run these subsubsteps:

    <ol>
     <li><p>If <var>token</var> is U+FEFF, set <b>BOM seen flag</b>.

     <li><p>Otherwise, if <var>token</var> is not <a>end-of-stream</a>, set
     <b>BOM seen flag</b> and append <var>token</var> to <var>output</var>.

     <li><p>Otherwise, return <var>output</var>.
    </ol>

   <li><p>Otherwise, if <var>token</var> is not <a>end-of-stream</a>, append
   <var>token</var> to <var>output</var>.

   <li><p>Otherwise, return <var>output</var>.
  </ol>
</ol>

<p class=note>This algorithm is intentionally different with respect to BOM handling from
the <a>decode</a> algorithm used by the rest of the platform to give API users more
control.

<hr>

<dl class=domintro>
 <dt><code><var>decoder</var> = new <a constructor lt="TextDecoder()">TextDecoder</a>([<var>label</var> = "utf-8" [, <var>options</var>]])</code>
 <dd>
  <p>Returns a new {{TextDecoder}} object.
  <p>If <var>label</var> is either not a <a>label</a> or is a
  <a>label</a> for <a>replacement</a>,
  <span data-anolis-spec=webidl title=throw>throws</a> a
  <code>RangeError</code>.

 <dt><code><var>decoder</var> . <a title=dom-TextDecoder-encoding>encoding</a></code>
 <dd><p>Returns <b>encoding</b>'s <a>name</a>, lowercased.

 <dt><code><var>decoder</var> . <a title=dom-TextDecoder-fatal>fatal</a></code>
 <dd><p>Returns true if <b>error mode</b> is "<code>fatal</code>", and false otherwise.

 <dt><code><var>decoder</var> . <a title=dom-TextDecoder-ignoreBOM>ignoreBOM</a></code>
 <dd><p>Returns true if <b>ignore BOM flag</b> is set, and false otherwise.

 <dt><code><var>decoder</var> . <a title=dom-TextDecoder-decode>decode</a>([<var>input</var> [, <var>options</var>]])</code>
 <dd>
  <p>Returns the result of running <b>encoding</b>'s <a>decoder</a>. The method can be invoked
  zero or more times with <var>options</var>'s <code title>stream</code> set to true, and then once
  without <var>options</var>'s <code title>stream</code> (or set to false), to process a fragmented
  stream. If the invocation without <var>options</var>'s <code title>stream</code> (or set to false)
  has no <var>input</var>, it's clearest to omit both arguments.

  <pre class=example>var string = "", decoder = TextDecoder(encoding), buffer;
while(buffer = next_chunk()) {
  string += decoder.decode(buffer, {stream:true});
}
string += decoder.decode(); // end-of-stream</pre>

  <p>If the <b>error mode</b> is "<code>fatal</code>" and <b>encoding</b>'s <a>decoder</a>
  returns <a>error</a>, <span data-anolis-spec=webidl title=throw>throws</a> a
  <code>TypeError</code>.
</dl>

<p>The
<dfn constructor for=TextDecoder>TextDecoder(<var>label</var>, <var>options</var>)</dfn>
constructor, when invoked, must run these steps:

<ol>
 <li><p>Let <var>encoding</var> be the result of
 <a>getting an encoding</a> from
 <var>label</var>.

 <li><p>If <var>encoding</var> is failure or <a>replacement</a>,
 <span data-anolis-spec=webidl>throw</a> a <code>RangeError</code>.

 <li><p>Let <var>dec</var> be a new {{TextDecoder}} object.

 <li><p>Set <var>dec</var>'s <b>encoding</b> to
 <var>encoding</var>.

 <li><p>If <var>options</var>'s <code title>fatal</code> member is
 true, set <var>dec</var>'s <b>error mode</b> to "<code>fatal</code>".

 <li><p>If <var>options</var>'s <code title>ignoreBOM</code> member is
 true, set <var>dec</var>'s <b>ignore BOM flag</b>.

 <li><p>Return <var>dec</var>.
</ol>

<p>The <dfn title=dom-TextDecoder-encoding><code>encoding</code></dfn> attribute's getter must
return <b>encoding</b>'s <a>name</a> in <a>ASCII lowercase</a>.

<p>The <dfn title=dom-TextDecoder-fatal><code>fatal</code></dfn> attribute's getter must
return true if <b>error mode</b> is "<code>fatal</code>", and false otherwise.

<p>The <dfn title=dom-TextDecoder-ignoreBOM><code>ignoreBOM</code></dfn> attribute's
getter must return true if <b>ignore BOM flag</b> is set, and false otherwise.

<p>The
<dfn title=dom-TextDecoder-decode><code>decode(<var>input</var>, <var>options</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>If the <b>do not flush flag</b> is unset, set <b>decoder</b> to a new
 <b>encoding</b>'s <a>decoder</a>, set <b>stream</b> to a new
 <a title=concept-stream>stream</a>, and unset the <b>BOM seen flag</b>.

 <li><p>If <var>options</var>'s <code title>stream</code> is true, set the
 <b>do not flush flag</b>, and unset the <b>do not flush flag</b> otherwise.

 <li><p>If <var>input</var> is given, <a title=concept-stream-push>push</a> a
 <span data-anolis-spec=webidl title="get a copy of the bytes held by the buffer source">copy of</a>
 <var>input</var> to <b>stream</b>.

 <li><p>Let <var>output</var> be a new <a title=concept-stream>stream</a>.

 <li>
  <p>While true:

  <ol>
   <li><p>Let <var>token</var> be the result of
   <a title=concept-stream-read>reading</a> from <b>stream</b>.

   <li>
    <p>If <var>token</var> is <a>end-of-stream</a> and the <b>do not flush flag</b> is set,
    return <var>output</var>, <a lt="serialize stream">serialized</a>.

    <p class=note>The way streaming works is to not handle <a>end-of-stream</a> here when the
    <b>do not flush flag</b> is set and to not unset that flag. That way in a subsequent invocation
    <b>decoder</b> is not set anew in the first step of the algorithm and its state is preserved.

   <li>
    <p>Otherwise, run these subsubsteps:

    <ol>
     <li><p>Let <var>result</var> be the result of
     <a title=concept-encoding-process>processing</a> <var>token</var> for
     <b>decoder</b>, <b>stream</b>, <var>output</var>, and <b>error mode</b>.

     <li><p>If <var>result</var> is <a>finished</a>, return <var>output</var>,
     <a lt="serialize stream">serialized</a>.

     <li><p>Otherwise, if <var>result</var> is <a>error</a>,
     <span data-anolis-spec=webidl title=throw>throw</a> a <code>TypeError</code>.

     <li><p>Otherwise, do nothing.
    </ol>
  </ol>
</ol>


<h3>Interface <code title>TextEncoder</code></h3>

<pre class=idl>[Constructor<!-- We cannot add an argument here
that is not the label argument it had previously. That would break content. -->,
 Exposed=Window,Worker]
interface TextEncoder {
  readonly attribute DOMString encoding;
  [NewObject] Uint8Array encode(optional USVString input = "");
};</pre>

<p>A <code>TextEncoder</code> object has an associated <b>encoder</b>.

<p class="note no-backref">A <code>TextEncoder</code> object offers no <var>label</var> argument as
it only supports <a>UTF-8</a>. It also offers no <code>stream</code> option as no
<a>encoder</a> requires buffering of scalar values.

<hr>

<dl class=domintro>
 <dt><code><var>encoder</var> = new <a constructor lt="TextEncoder()">TextEncoder</a>()</code>
 <dd><p>Returns a new <code>TextEncoder</code> object.

 <dt><code><var>encoder</var> . <a title=dom-TextEncoder-encoding>encoding</a></code>
 <dd><p>Returns "<code title>utf-8</code>".

 <dt><code><var>encoder</var> . <a title=dom-TextEncoder-encode>encode</a>([<var>input</var> = ""])</code>
 <dd><p>Returns the result of running <a>UTF-8</a>'s <a>encoder</a>.
</dl>

<p>The <dfn constructor for=TextEncoder>TextEncoder()</dfn> constructor, when invoked, must
run these steps:

<ol>
 <li><p>Let <var>enc</var> be a new <code>TextEncoder</code> object.

 <li><p>Set <var>enc</var>'s <b>encoder</b> to <a>UTF-8</a>'s <a>encoder</a>.

 <li><p>Return <var>enc</var>.
</ol>

<p>The <dfn title=dom-TextEncoder-encoding><code>encoding-yyy</code></dfn> attribute's getter must
return "<code title>utf-8</code>".

<p>The
<dfn title=dom-TextEncoder-encode><code>encode(<var>input</var>)</code></dfn>
method, when invoked, must run these steps:

<ol>
 <li><p>Convert <var>input</var> to a <a title=concept-stream>stream</a>.

 <li><p>Let <var>output</var> be a new <a title=concept-stream>stream</a>.

 <li>
  <p>While true, run these substeps:

  <ol>
   <li><p>Let <var>token</var> be the result of
   <a title=concept-stream-read>reading</a> from <var>input</var>.

   <li><p>Let <var>result</var> be the result of
   <a title=concept-encoding-process>processing</a> <var>token</var> for
   <b>encoder</b>, <var>input</var>, <var>output</var>.

   <li>
    <p>If <var>result</var> is <a>finished</a>, convert <var>output</var> into a
    byte sequence, and then return a <code title>Uint8Array</code> object wrapping an
    <code title>ArrayBuffer</code> containing <var>output</var>.
    <!-- XXX https://www.w3.org/Bugs/Public/show_bug.cgi?id=26966 -->

    <p class=note>These <a title=encoding>encodings</a> cannot return
    <a>error</a>.
  </ol>
</ol>



<h2>The encoding</h2>

<h3><dfn>UTF-8</dfn></h3>

<h4><dfn>UTF-8 decoder</dfn></h4>

<p><a>UTF-8</a>'s <a>decoder</a>'s has an associated
<dfn>UTF-8 code point</dfn>, <dfn>UTF-8 bytes seen</dfn>, and
<dfn>UTF-8 bytes needed</dfn> (all initially 0), a <dfn>UTF-8 lower boundary</dfn>
(initially 0x80), and a <dfn>UTF-8 upper boundary</dfn> (initially 0xBF).

<p><a>UTF-8</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>UTF-8 bytes needed</a> is not 0, set
 <a>UTF-8 bytes needed</a> to 0 and return <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li>
  <p>If <a>UTF-8 bytes needed</a> is 0, based on <var>byte</var>:

  <dl class=switch>
   <dt>0x00 to 0x7F
   <dd><p>Return a code point whose value is <var>byte</var>.

   <dt>0xC2 to 0xDF
   <dd>
    <ol>
     <li><p>Set <a>UTF-8 bytes needed</a> to 1.

     <li>
      <p>Set <a>UTF-8 code point</a> to <var>byte</var> &amp; 0x1F.

      <p class="note">The five least significant bits of <var>byte</var>.
    </ol>

   <dt>0xE0 to 0xEF
   <dd>
    <ol>
     <li><p>If <var>byte</var> is 0xE0, set
     <a>UTF-8 lower boundary</a> to 0xA0.

     <li><p>If <var>byte</var> is 0xED, set
     <a>UTF-8 upper boundary</a> to 0x9F.

     <li><p>Set <a>UTF-8 bytes needed</a> to 2.

     <li>
      <p>Set <a>UTF-8 code point</a> to <var>byte</var> &amp; 0xF.

      <p class="note">The four least significant bits of <var>byte</var>.
    </ol>

   <dt>0xF0 to 0xF4
   <dd>
    <ol>
     <li><p>If <var>byte</var> is 0xF0, set
     <a>UTF-8 lower boundary</a> to 0x90.

     <li><p>If <var>byte</var> is 0xF4, set
     <a>UTF-8 upper boundary</a> to 0x8F.

     <li><p>Set <a>UTF-8 bytes needed</a> to 3.

     <li>
      <p>Set <a>UTF-8 code point</a> to <var>byte</var> &amp; 0x7.

      <p class="note">The three least significant bits of <var>byte</var>.
    </ol>

   <dt>Otherwise
   <dd><p>Return <a>error</a>.
  </dl>

  <p>Return <a>continue</a>.

 <li>
  <p>If <var>byte</var> is not in the range
  <a>UTF-8 lower boundary</a> to <a>UTF-8 upper boundary</a>, inclusive,
  run these substeps:

  <ol>
   <li><p>Set <a>UTF-8 code point</a>,
   <a>UTF-8 bytes needed</a>, and <a>UTF-8 bytes seen</a> to 0,
   set <a>UTF-8 lower boundary</a> to 0x80, and set
   <a>UTF-8 upper boundary</a> to 0xBF.

   <li><p><a title=concept-stream-prepend>Prepend</a> <var>byte</var> to
   <var>stream</var>.

   <li><p>Return <a>error</a>.
  </ol>

 <li><p>Set <a>UTF-8 lower boundary</a> to 0x80 and
 <a>UTF-8 upper boundary</a> to 0xBF.

 <li>
  <p>Set <a>UTF-8 code point</a> to (<a>UTF-8 code point</a> &lt;&lt; 6) |
  (<var>byte</var> &amp; 0x3F)

  <p class="note no-backref">Shift the existing bits of <a>UTF-8 code point</a> left by six
  places and set the newly-vacated six least significant bits to the six least significant bits of
  <var>byte</var>.

 <li><p>Increase <a>UTF-8 bytes seen</a> by one.

 <li><p>If <a>UTF-8 bytes seen</a> is not equal to
 <a>UTF-8 bytes needed</a>, return <a>continue</a>.

 <li><p>Let <var>code point</var> be <a>UTF-8 code point</a>.

 <li><p>Set <a>UTF-8 code point</a>,
 <a>UTF-8 bytes needed</a>, and <a>UTF-8 bytes seen</a> to 0.

 <li><p>Return a code point whose value is <var>code point</var>.
</ol>

<p class=note>The constraints in the <a>UTF-8 decoder</a> above match
‚ÄúBest Practices for Using U+FFFD‚Äù from the Unicode standard. No other
behavior is permitted per the Encoding Standard (other algorithms that
achieve the same result are obviously fine, even encouraged).
[[!UNICODE]]


<h4><dfn>UTF-8 encoder</dfn></h4>

<p><a>UTF-8</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li>
  <p>Set <var>count</var> and <var>offset</var> based on the
  range <var>code point</var> is in:

  <dl class=switch>
   <dt>U+0080 to U+07FF, inclusive
   <dd>1 and 0xC0
   <dt>U+0800 to U+FFFF, inclusive
   <dd>2 and 0xE0
   <dt>U+10000 to U+10FFFF, inclusive
   <dd>3 and 0xF0
  </dl>

 <li><p>Let <var>bytes</var> be a byte sequence whose first byte is
 (<var>code point</var> >> (6 &times; <var>count</var>)) + <var>offset</var>.

 <li>
  <p>Run these substeps while <var>count</var> is greater than 0:

  <ol>
   <li><p>Set <var>temp</var> to
   <var>code point</var> >> (6 &times; (<var>count</var> &minus; 1)).

   <li><p>Append to <var>bytes</var> 0x80 | (<var>temp</var> &amp; 0x3F).

   <li><p>Decrease <var>count</var> by one.
  </ol>

 <li><p>Return bytes <var>bytes</var>, in order.
</ol>

<p class=note>This algorithm has identical results to the one described in the Unicode standard. It
is included here for completeness. [[!UNICODE]]



<h2>Legacy single-byte encodings</h2>

<p>An <a>encoding</a> where each byte is either a single code point or
nothing, is a <dfn>single-byte encoding</dfn>.
<a title="single-byte encoding">Single-byte encodings</a> share the
<a>decoder</a> and <a>encoder</a>. <dfn>Index single-byte</dfn>,
as referenced by the <a>single-byte decoder</a> and
<a>single-byte encoder</a>,  is defined by the following table, and
depends on the <a>single-byte encoding</a> in use. All but two
<a title="single-byte encoding">single-byte encodings</a> have a
unique <a>index</a>.

<table>
 <tr><th><a>Name</name><th><a>Index</a>
 <tr><td><dfn>IBM866</dfn><td><a href=index-ibm866.txt>index-ibm866.txt</a>
 <tr><td><dfn>ISO-8859-2</dfn><td><a href=index-iso-8859-2.txt>index-iso-8859-2.txt</a>
 <tr><td><dfn>ISO-8859-3</dfn><td><a href=index-iso-8859-3.txt>index-iso-8859-3.txt</a>
 <tr><td><dfn>ISO-8859-4</dfn><td><a href=index-iso-8859-4.txt>index-iso-8859-4.txt</a>
 <tr><td><dfn>ISO-8859-5</dfn><td><a href=index-iso-8859-5.txt>index-iso-8859-5.txt</a>
 <tr><td><dfn>ISO-8859-6</dfn><td><a href=index-iso-8859-6.txt>index-iso-8859-6.txt</a>
 <tr><td><dfn>ISO-8859-7</dfn><td><a href=index-iso-8859-7.txt>index-iso-8859-7.txt</a>
 <tr><td><dfn>ISO-8859-8</dfn><td rowspan=2><a href=index-iso-8859-8.txt>index-iso-8859-8.txt</a>
 <tr><td><dfn>ISO-8859-8-I</dfn>
 <tr><td><dfn>ISO-8859-10</dfn><td><a href=index-iso-8859-10.txt>index-iso-8859-10.txt</a>
 <tr><td><dfn>ISO-8859-13</dfn><td><a href=index-iso-8859-13.txt>index-iso-8859-13.txt</a>
 <tr><td><dfn>ISO-8859-14</dfn><td><a href=index-iso-8859-14.txt>index-iso-8859-14.txt</a>
 <tr><td><dfn>ISO-8859-15</dfn><td><a href=index-iso-8859-15.txt>index-iso-8859-15.txt</a>
 <tr><td><dfn>ISO-8859-16</dfn><td><a href=index-iso-8859-16.txt>index-iso-8859-16.txt</a>
 <tr><td><dfn>KOI8-R</dfn><td><a href=index-koi8-r.txt>index-koi8-r.txt</a>
 <tr><td><dfn>KOI8-U</dfn><td><a href=index-koi8-u.txt>index-koi8-u.txt</a>
 <tr><td><dfn>macintosh</dfn><td><a href=index-macintosh.txt>index-macintosh.txt</a>
 <tr><td><dfn>windows-874</dfn><td><a href=index-windows-874.txt>index-windows-874.txt</a>
 <tr><td><dfn>windows-1250</dfn><td><a href=index-windows-1250.txt>index-windows-1250.txt</a>
 <tr><td><dfn>windows-1251</dfn><td><a href=index-windows-1251.txt>index-windows-1251.txt</a>
 <tr><td><dfn>windows-1252</dfn><td><a href=index-windows-1252.txt>index-windows-1252.txt</a>
 <tr><td><dfn>windows-1253</dfn><td><a href=index-windows-1253.txt>index-windows-1253.txt</a>
 <tr><td><dfn>windows-1254</dfn><td><a href=index-windows-1254.txt>index-windows-1254.txt</a>
 <tr><td><dfn>windows-1255</dfn><td><a href=index-windows-1255.txt>index-windows-1255.txt</a>
 <tr><td><dfn>windows-1256</dfn><td><a href=index-windows-1256.txt>index-windows-1256.txt</a>
 <tr><td><dfn>windows-1257</dfn><td><a href=index-windows-1257.txt>index-windows-1257.txt</a>
 <tr><td><dfn>windows-1258</dfn><td><a href=index-windows-1258.txt>index-windows-1258.txt</a>
 <tr><td><dfn>x-mac-cyrillic</dfn><td><a href=index-x-mac-cyrillic.txt>index-x-mac-cyrillic.txt</a>
</table>

<p class=note><a>ISO-8859-8</a> and <a>ISO-8859-8-I</a> are
distinct <a>encoding</a> <a title=name>names</a>, because
<a>ISO-8859-8</a> has influence on the layout direction. And although
historically this might have been the case for <a>ISO-8859-6</a> and
"iso-8859-6-i" as well, that is no longer true.
<!-- https://www.w3.org/Bugs/Public/show_bug.cgi?id=19505 -->

<h3><dfn>single-byte decoder</dfn></h3>

<p><a title="single-byte encoding">Single-byte encodings</a>'s
<a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return a code point whose value
 is <var>byte</var>.

 <li><p>Let <var>code point</var> be the <a>index code point</a>
 for <var>byte</var> &minus; 0x80 in <a>index single-byte</a>.

 <li><p>If <var>code point</var> is null, return <a>error</a>.

 <li><p>Return a code point whose value is <var>code point</var>.
</ol>

<h3><dfn>single-byte encoder</dfn></h3>

<p><a title="single-byte encoding">Single-byte encodings</a>'s
<a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li><p>Let <var>pointer</var> be the <a>index pointer</a> for
 <var>code point</var> in <a>index single-byte</a>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>Return a byte whose value is <var>pointer</var> + 0x80.
</ol>



<h2 id=legacy-multi-byte-chinese-(simplified)-encodings>Legacy multi-byte Chinese (simplified) encodings</h2>

<h3><dfn>GBK</dfn></h3>

<h4><dfn>GBK decoder</dfn></h4>

<p><a>GBK</a>'s <a>decoder</a> is <a>gb18030</a>'s <a>decoder</a>.


<h4><dfn>GBK encoder</dfn></h4>

<p><a>GBK</a>'s <a>encoder</a> is <a>gb18030</a>'s <a>encoder</a>
with its <a>GBK flag</a> set.

<p class="note no-backref">Not fully aliasing <a>GBK</a> with <a>gb18030</a>
is a conservative move to decrease the chances of breaking legacy servers and other
consumers of content generated with <a>GBK</a>'s <a>encoder</a>.


<h3><dfn>gb18030</dfn></h3>

<h4><dfn>gb18030 decoder</dfn></h4>

<p><a>gb18030</a>'s <a>decoder</a> has an associated <dfn>gb18030 first</dfn>,
<dfn>gb18030 second</dfn>, and <dfn>gb18030 third</dfn> (all initially 0x00).

<p><a>gb18030</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>gb18030 first</a>, <a>gb18030 second</a>, and <a>gb18030 third</a>
 are 0x00, return <a>finished</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a>, and
 <a>gb18030 first</a>, <a>gb18030 second</a>, or <a>gb18030 third</a>
 is not 0x00, set <a>gb18030 first</a>, <a>gb18030 second</a>, and
 <a>gb18030 third</a> to 0x00, and return <a>error</a>.

 <li>
  <p>If <a>gb18030 third</a> is not 0x00, run these substeps:

  <ol>
   <li><p>Let <var>code point</var> be null.

   <li><p>If <var>byte</var> is in the range 0x30 to 0x39, inclusive, set
   <var>code point</var> to the
   <a>index gb18030 ranges code point</a> for
   (((<a>gb18030 first</a> &minus; 0x81) &times; 10 + <a>gb18030 second</a> &minus; 0x30) &times; 126 + <a>gb18030 third</a> &minus; 0x81) &times; 10 + <var>byte</var> &minus; 0x30.

   <li><p>Let <var>buffer</var> be a byte sequence consisting of
   <a>gb18030 second</a>, <a>gb18030 third</a>, and <var>byte</var>, in
   order.

   <li><p>Set <a>gb18030 first</a>, <a>gb18030 second</a>, and
   <a>gb18030 third</a> to 0x00.

   <li><p>If <var>code point</var> is null,
   <a title=concept-stream-prepend>prepend</a> <var>buffer</var> to
   <var>stream</var> and return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li>
  <p>If <a>gb18030 second</a> is not 0x00, run these substeps:

  <ol>
   <li><p>If <var>byte</var> is in the range 0x81 to 0xFE, inclusive, set
   <a>gb18030 third</a> to <var>byte</var> and return <a>continue</a>.

   <li><p><a title=concept-stream-prepend>Prepend</a> <a>gb18030 second</a>
   followed by <var>byte</var> to <var>stream</var>, set
   <a>gb18030 first</a> and <a>gb18030 second</a> to 0x00, and return
   <a>error</a>.
  </ol>

 <li>
  <p>If <a>gb18030 first</a> is not 0x00, run these substeps:

  <ol>
   <li><p>If <var>byte</var> is in the range 0x30 to 0x39, inclusive, set
   <a>gb18030 second</a> to <var>byte</var> and return <a>continue</a>.

   <li><p>Let <var>lead</var> be <a>gb18030 first</a>, let
   <var>pointer</var> be null, and set <a>gb18030 first</a> to 0x00.

   <li><p>Let <var>offset</var> be 0x40 if <var>byte</var> is
   less than 0x7F and 0x41 otherwise.

   <li><p>If <var>byte</var> is in the range 0x40 to 0x7E, inclusive, or
   0x80 to 0xFE, inclusive, set <var>pointer</var> to
   (<var>lead</var> &minus; 0x81) &times; 190 + (<var>byte</var> &minus; <var>offset</var>).

   <li><p>Let <var>code point</var> be null if
   <var>pointer</var> is null and the <a>index code point</a>
   for <var>pointer</var> in <a>index gb18030</a> otherwise.

   <li><p>If <var>code point</var> is null and <var>byte</var> is an
   <a>ASCII byte</a>, <a title=concept-stream-prepend>prepend</a>
   <var>byte</var> to <var>stream</var>.

   <li><p>If <var>code point</var> is null, return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return
 a code point whose value is <var>byte</var>.

 <li><p>If <var>byte</var> is 0x80, return code point U+20AC.

 <li><p>If <var>byte</var> is in the range 0x81 to 0xFE, inclusive, set
 <a>gb18030 first</a> to <var>byte</var> and return <a>continue</a>.

 <li><p>Return <a>error</a>.
</ol>


<h4><dfn>gb18030 encoder</dfn></h4>

<p><a>gb18030</a>'s <a>encoder</a> has an associated <dfn>GBK flag</dfn>
(initially unset).

<p><a>gb18030</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li>
  <p>If <var>code point</var> is U+E5E5, return <a>error</a> with <var>code point</var>.

  <p class="note"><a>Index gb18030</a> maps 0xA3 0xA0 to U+3000 rather than U+E5E5 for
  compatibility with deployed content. Therefore it cannot roundtrip.

 <li><p>If the <a>GBK flag</a> is set and <var>code point</var> is
 U+20AC, return byte 0x80.

 <li><p>Let <var>pointer</var> be the <a>index pointer</a> for
 <var>code point</var> in <a>index gb18030</a>.

 <li>
  <p>If <var>pointer</var> is not null, run these substeps:

  <ol>
   <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 190) + 0x81.

   <li><p>Let <var>trail</var> be <var>pointer</var> % 190.

   <li><p>Let <var>offset</var> be 0x40 if <var>trail</var> is
   less than 0x3F<!--0x7F-0x40--> and 0x41 otherwise.

   <li><p>Return two bytes whose values are <var>lead</var> and
   <var>trail</var> + <var>offset</var>.
  </ol>

 <li><p>If <a>GBK flag</a> is set, return <a>error</a> with
 <var>code point</var>.

 <li><p>Set <var>pointer</var> to the
 <a>index gb18030 ranges pointer</a> for <var>code point</var>.

 <li><p>Let <var>byte1</var> be floor(<var>pointer</var> / 10 / 126 / 10).

 <li><p>Set <var>pointer</var> to
 <var>pointer</var> &minus; <var>byte1</var> &times; 10 &times; 126 &times; 10.

 <li><p>Let <var>byte2</var> be floor(<var>pointer</var> / 10 / 126).

 <li><p>Set <var>pointer</var> to
 <var>pointer</var> &minus; <var>byte2</var> &times; 10 &times; 126.

 <li><p>Let <var>byte3</var> be floor(<var>pointer</var> / 10).

 <li><p>Let <var>byte4</var> be
 <var>pointer</var> &minus; <var>byte3</var> &times; 10.

 <li><p>Return four bytes whose values are <var>byte1</var> + 0x81,
 <var>byte2</var> + 0x30, <var>byte3</var> + 0x81,
 <var>byte4</var> + 0x30.
</ol>



<h2 id=legacy-multi-byte-chinese-(traditional)-encodings>Legacy multi-byte Chinese (traditional) encodings</h2>

<!--
 Lead:  0x81 to 0xFE
 Trail: 0x40 to 0x7E or 0xA1 to 0xFE
-->


<h3><dfn>Big5</dfn></h3>

<h4><dfn>Big5 decoder</dfn></h4>

<p><a>Big5</a>'s <a>decoder</a> has an associated
<dfn>Big5 lead</dfn> (initially 0x00).

<a>Big5</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and <a>Big5 lead</a>
 is not 0x00, set <a>Big5 lead</a> to 0x00 and return <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a> and <a>Big5 lead</a>
 is 0x00, return <a>finished</a>.

 <li>
  <p>If <a>Big5 lead</a> is not 0x00, let <var>lead</var> be
  <a>Big5 lead</a>, let <var>pointer</var> be null, set
  <a>Big5 lead</a> to 0x00, and then run these substeps:

  <ol>
   <li><p>Let <var>offset</var> be 0x40 if <var>byte</var> is
   less than 0x7F and 0x62 otherwise.
   <!-- 0x62 = 0xA1-0x7E+1+0x40 -->

   <li><p>If <var>byte</var> is in the range 0x40 to 0x7E, inclusive, or
   0xA1 to 0xFE, inclusive, set <var>pointer</var> to
   (<var>lead</var> &minus; 0x81) &times; 157 + (<var>byte</var> &minus; <var>offset</var>).

   <li>
    <p>If there is a row in the table below whose first column is
    <var>pointer</var>, return the <em>two</em> code points listed in
    its second column (the third column is irrelevant):

    <table>
     <tr><th>Pointer<th>Code points<th>Notes<!-- http://www.unicode.org/Public/UNIDATA/NamedSequences.txt -->
     <tr><td>1133<!-- 0x88 0x62 --><td>U+00CA U+0304<td>√äÃÑ (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND MACRON)
     <tr><td>1135<!-- 0x88 0x64 --><td>U+00CA U+030C<td>√äÃå (LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND CARON)
     <tr><td>1164<!-- 0x88 0xA3 --><td>U+00EA U+0304<td>√™ÃÑ (LATIN SMALL LETTER E WITH CIRCUMFLEX AND MACRON)
     <tr><td>1166<!-- 0x88 0xA5 --><td>U+00EA U+030C<td>√™Ãå (LATIN SMALL LETTER E WITH CIRCUMFLEX AND CARON)
    </table>
    <!-- we do this to avoid PUA -->

    <p class=note>Since <a title=index>indexes</a> are limited to
    single code points this table is used for these pointers.

   <li><p>Let <var>code point</var> be null if
   <var>pointer</var> is null and the <a>index code point</a>
   for <var>pointer</var> in <a>index Big5</a> otherwise.

   <li><p>If <var>code point</var> is null and <var>byte</var> is an
   <a>ASCII byte</a>, <a title=concept-stream-prepend>prepend</a>
   <var>byte</var> to <var>stream</var>.

   <li><p>If <var>code point</var> is null, return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return
 a code point whose value is <var>byte</var>.

 <li><p>If <var>byte</var> is in the range 0x81 to 0xFE, inclusive, set
 <a>Big5 lead</a> to <var>byte</var> and return <a>continue</a>.

 <li><p>Return <a>error</a>.
</ol>


<h4><dfn>Big5 encoder</dfn></h4>

<p><a>Big5</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li><p>Let <var>pointer</var> be the <a>index Big5 pointer</a> for
 <var>code point</var>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 157) + 0x81.

 <li><p>Let <var>trail</var> be <var>pointer</var> % 157.

 <li><p>Let <var>offset</var> be 0x40 if <var>trail</var> is
 less than 0x3F<!--0x7F-0x40--> and 0x62<!--0xA1-0x3F--> otherwise.

 <li><p>Return two bytes whose values are <var>lead</var> and
 <var>trail</var> + <var>offset</var>.
</ol>



<h2>Legacy multi-byte Japanese encodings</h2>

<h3><dfn>EUC-JP</dfn></h3>
<!-- https://www.iana.org/assignments/charset-reg/CP51932 -->

<h4><dfn>EUC-JP decoder</dfn></h4>

<p><a>EUC-JP</a>'s <a>decoder</a> has an associated
<dfn>EUC-JP jis0212 flag</dfn> (initially unset) and
<dfn>EUC-JP lead</dfn> (initially 0x00).

<p><a>EUC-JP</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>EUC-JP lead</a> is not 0x00, set <a>EUC-JP lead</a> to 0x00, and return
 <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>EUC-JP lead</a> is 0x00, return <a>finished</a>.

 <li><p>If <a>EUC-JP lead</a> is 0x8E and <var>byte</var> is
 in the range 0xA1 to 0xDF, inclusive, set <a>EUC-JP lead</a> to 0x00 and return
 a code point whose value is 0xFF61 + <var>byte</var> &minus; 0xA1.
 <!-- katakana -->

 <li><p>If <a>EUC-JP lead</a> is 0x8F and <var>byte</var> is in the range
 0xA1 to 0xFE, inclusive, set the <a>EUC-JP jis0212 flag</a>, set
 <a>EUC-JP lead</a> to <var>byte</var>, and return <a>continue</a>.

 <li>
  <p>If <a>EUC-JP lead</a> is not 0x00, let <var>lead</var> be
  <a>EUC-JP lead</a>, set <a>EUC-JP lead</a> to 0x00, and run these substeps:

  <ol>
   <li><p>Let <var>code point</var> be null.

   <li><p>If <var>lead</var> and <var>byte</var> are both in the
   range 0xA1 to 0xFE, inclusive, set <var>code point</var> to the
   <a>index code point</a> for
   (<var>lead</var> &minus; 0xA1) &times; 94 + <var>byte</var> &minus; 0xA1
   in <a>index jis0208</a> if the <a>EUC-JP jis0212 flag</a> is unset and in
   <a>index jis0212</a> otherwise.

   <li><p>Unset the <a>EUC-JP jis0212 flag</a>.

   <li><p>If <var>byte</var> is not in the range 0xA1 to 0xFE, inclusive,
   <a title=concept-stream-prepend>prepend</a> <var>byte</var> to
   <var>stream</var>.

   <li><p>If <var>code point</var> is null, return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return
 a code point whose value is <var>byte</var>.

 <li><p>If <var>byte</var> is 0x8E, 0x8F, or in the range 0xA1 to
 0xFE, inclusive, set <a>EUC-JP lead</a> to <var>byte</var> and return
 <a>continue</a>.

 <li><p>Return <a>error</a>.
</ol>


<h4><dfn>EUC-JP encoder</dfn></h4>

<p><a>EUC-JP</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li><p>If <var>code point</var> is U+00A5, return byte 0x5C.

 <li><p>If <var>code point</var> is U+203E, return byte 0x7E.

 <li><p>If <var>code point</var> is in the range U+FF61 to U+FF9F, inclusive, return
 two bytes whose values are 0x8E and <var>code point</var> &minus; 0xFF61 + 0xA1.

 <li><p>If <var>code point</var> is U+2212, set it to U+FF0D.

 <li><p>Let <var>pointer</var> be the <a>index pointer</a> for
 <var>code point</var> in <a>index jis0208</a>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 94) + 0xA1.

 <li><p>Let <var>trail</var> be <var>pointer</var> % 94 + 0xA1.

 <li><p>Return two bytes whose values are <var>lead</var> and
 <var>trail</var>.
</ol>


<h3><dfn>ISO-2022-JP</dfn></h3>
<!--
 https://tools.ietf.org/html/rfc1468
 https://tools.ietf.org/html/rfc2237 (iso-2022-jp-1; not used)
 "ESC ) I" is from iso-2022-jp-3 reportedly
-->

<h4><dfn>ISO-2022-JP decoder</dfn></h4>

<p><a>ISO-2022-JP</a>'s <a>decoder</a> has an associated
<dfn>ISO-2022-JP decoder state</dfn> (initially
<a title="iso-2022-jp decoder ASCII">ASCII</a>),
<dfn>ISO-2022-JP decoder output state</dfn> (initially
<a title="iso-2022-jp decoder ASCII">ASCII</a>),
<dfn>ISO-2022-JP lead</dfn> (initially 0x00), and
<dfn>ISO-2022-JP output flag</dfn> (initially unset).

<p><a>ISO-2022-JP</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps, switching on
<a>ISO-2022-JP decoder state</a>:

<dl class=switch>
 <dt><dfn title="iso-2022-jp decoder ASCII">ASCII-aaa</dfn>
 <dd>
  <p>Based on <var>byte</var>:

  <dl class=switch>
   <dt>0x1B
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape start">escape start</a> and return
   <a>continue</a>.

   <dt>0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return a code point whose
   value is <var>byte</var>.

   <dt><a>end-of-stream</a>
   <dd><p>Return <a>finished</a>.

   <dt>Otherwise
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return <a>error</a>.
  </dl>

 <dt><dfn title="iso-2022-jp decoder Roman">Roman-ttt</dfn>
 <dd>
  <p>Based on <var>byte</var>:

  <dl class=switch>
   <dt>0x1B
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape start">escape start</a> and return
   <a>continue</a>.

   <dt>0x5C
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return code point U+00A5.

   <dt>0x7E
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return code point U+203E.

   <dt>0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return a code point whose
   value is <var>byte</var>.

   <dt><a>end-of-stream</a>
   <dd><p>Return <a>finished</a>.

   <dt>Otherwise
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return <a>error</a>.
  </dl>

 <dt><dfn title="iso-2022-jp decoder Katakana">Katakana</dfn>
 <dd>
  <p>Based on <var>byte</var>:
  <dl class=switch>
   <dt>0x1B
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape start">escape start</a> and return
   <a>continue</a>.

   <dt>0x21 to 0x5F
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return a code point whose
   value is 0xFF61 + <var>byte</var> &minus; 0x21.
   <!-- katakana -->

   <dt><a>end-of-stream</a>
   <dd><p>Return <a>finished</a>.

   <dt>Otherwise
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return <a>error</a>.
  </dl>

 <dt><dfn title="iso-2022-jp decoder lead byte">Lead byte</dfn>
 <dd>
  <p>Based on <var>byte</var>:
  <dl class=switch>
   <dt>0x1B
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape start">escape start</a> and return
   <a>continue</a>.

   <dt>0x21 to 0x7E
   <dd><p>Unset the <a>ISO-2022-JP output flag</a>, set
   <a>ISO-2022-JP lead</a> to <var>byte</var>,
   <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder trail byte">trail byte</a>, and return
   <a>continue</a>.

   <dt><a>end-of-stream</a>
   <dd><p>Return <a>finished</a>.

   <dt>Otherwise
   <dd><p>Unset the <a>ISO-2022-JP output flag</a> and return <a>error</a>.
  </dl>

 <dt><dfn title="iso-2022-jp decoder trail byte">Trail byte</dfn>
 <dd>
  <p>Based on <var>byte</var>:
  <dl class=switch>
   <dt>0x1B
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape start">escape start</a> and return
   <a>error</a>.
   <!-- iso-2022-jp decoder output state is still lead byte -->

   <dt>0x21 to 0x7E
   <dd>
    <ol>
     <li><p>Set the <a>ISO-2022-JP decoder state</a> to
     <a title="iso-2022-jp decoder lead byte">lead byte</a>.

     <li><p>Let <var>pointer</var> be
     (<a>ISO-2022-JP lead</a> &minus; 0x21) &times; 94 + <var>byte</var> &minus; 0x21.

     <li><p>Let <var>code point</var> be the <a>index code point</a> for
     <var>pointer</var> in <a>index jis0208</a>.

     <li><p>If <var>code point</var> is null, return <a>error</a>.

     <li><p>Return a code point whose value is <var>code point</var>.
    </ol>

   <dt><a>end-of-stream</a>
   <dd><p>Set the <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder lead byte">lead byte</a>,
   <a title=concept-stream-prepend>prepend</a> <var>byte</var> to
   <var>stream</var>, and return <a>error</a>.

   <dt>Otherwise
   <dd><p>Set <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder lead byte">lead byte</a> and return
   <a>error</a>.
   <!-- iso-2022-jp decoder output state is still lead byte -->
  </dl>

 <dt><dfn title="iso-2022-jp decoder escape start">Escape start</dfn>
 <dd>
  <ol>
   <li><p>If <var>byte</var> is either <!--$-->0x24 or <!--(-->0x28, set
   <a>ISO-2022-JP lead</a> to <var>byte</var>,
   <a>ISO-2022-JP decoder state</a> to
   <a title="iso-2022-jp decoder escape">escape</a>, and return
   <a>continue</a>.

   <li><p><a title=concept-stream-prepend>Prepend</a> <var>byte</var> to
   <var>stream</var>.

   <li><p>Unset the <a>ISO-2022-JP output flag</a>, set
   <a>ISO-2022-JP decoder state</a> to
   <a>ISO-2022-JP decoder output state</a>, and return <a>error</a>.
  </ol>

 <dt><dfn title="iso-2022-jp decoder escape">Escape</dfn>
 <dd>
  <ol>
   <li><p>Let <var>lead</var> be <a>ISO-2022-JP lead</a> and set
   <a>ISO-2022-JP lead</a> to 0x00.

   <li><p>Let <var>state</var> be null.

   <li><p>If <var>lead</var> is 0x28 and <var>byte</var> is 0x42<!--B-->, set
   <var>state</var> to <a title="iso-2022-jp decoder ASCII">ASCII</a>.

   <li><p>If <var>lead</var> is 0x28 and <var>byte</var> is 0x4A<!--J-->, set
   <var>state</var> to <a title="iso-2022-jp decoder Roman">Roman</a>.

   <li><p>If <var>lead</var> is 0x28 and <var>byte</var> is 0x49<!--I-->, set
   <var>state</var> to <a title="iso-2022-jp decoder Katakana">Katakana</a>.

   <li><p>If <var>lead</var> is 0x24 and <var>byte</var> is either
   0x40<!--@--> or 0x42<!--B-->, set <var>state</var> to
   <a title="iso-2022-jp decoder lead byte">lead byte</a>.

   <li>
    <p>If <var>state</var> is non-null, run these substeps:

    <ol>
     <li><p>Set <a>ISO-2022-JP decoder state</a> and
     <a>ISO-2022-JP decoder output state</a> to <var>state</var>.

     <li><p>Let <var>output flag</var> be the <a>ISO-2022-JP output flag</a>.

     <li><p>Set the <a>ISO-2022-JP output flag</a>.

     <li><p>Return <a>continue</a>, if <var>output flag</var> is unset, and
     <a>error</a> otherwise.
    </ol>

   <li><p><a title=concept-stream-prepend>Prepend</a>
   <var>lead</var> and <var>byte</var> to <var>stream</var>.

   <li><p>Unset the <a>ISO-2022-JP output flag</a>, set
   <a>ISO-2022-JP decoder state</a> to <a>ISO-2022-JP decoder output state</a>
   and return <a>error</a>.
  </ol>
</dl>


<h4><dfn>ISO-2022-JP encoder</dfn></h4>

<p><a>ISO-2022-JP</a>'s <a>encoder</a> has an associated
<dfn>ISO-2022-JP encoder state</dfn> which is <dfn title="iso-2022-jp encoder ASCII">ASCII</dfn>,
<dfn title="iso-2022-jp encoder Roman">Roman</dfn>, or
<dfn title="iso-2022-jp encoder jis0208">jis0208</dfn> (initially
<a title="iso-2022-jp encoder ASCII">ASCII</a>).

<p><a>ISO-2022-JP</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a> and
 <a>ISO-2022-JP encoder state</a> is not
 <a title="iso-2022-jp encoder ASCII">ASCII</a>,
 <a title=concept-stream-prepend>prepend</a> <var>code point</var> to
 <var>stream</var>, set <a>ISO-2022-JP encoder state</a> to
 <a title="iso-2022-jp encoder ASCII">ASCII</a>, and return three bytes
 0x1B 0x28 0x42.

 <li><p>If <var>code point</var> is <a>end-of-stream</a> and
 <a>ISO-2022-JP encoder state</a> is
 <a title="iso-2022-jp encoder ASCII">ASCII</a>, return <a>finished</a>.

 <li>
  <p>If <a>ISO-2022-JP encoder state</a> is
  <a title="iso-2022-jp encoder ASCII">ASCII</a> or
  <a title="iso-2022-jp encoder Roman">Roman</a>, and <var>code point</var> is U+000E, U+000F,
  or U+001B, return <a>error</a> with U+FFFD.

  <p class="note">This returns U+FFFD rather than the <var>code point</var> to prevent attacks.
  <!-- https://github.com/whatwg/encoding/issues/15 -->

 <li><p>If <a>ISO-2022-JP encoder state</a> is
 <a title="iso-2022-jp encoder ASCII">ASCII</a> and <var>code point</var> is an
 <a>ASCII code point</a>, return a byte whose value is <var>code point</var>.

 <li>
  <p>If <a>ISO-2022-JP encoder state</a> is
  <a title="iso-2022-jp encoder Roman">Roman</a> and <var>code point</var> is an
  <a>ASCII code point</a>, excluding U+005C and U+007E, or is U+00A5 or U+203E, run
  these substeps:

  <ol>
   <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return a byte
   whose value is <var>code point</var>.

   <li><p>If <var>code point</var> is U+00A5, return byte 0x5C.

   <li><p>If <var>code point</var> is U+203E, return byte 0x7E.
  </ol>

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, and
 <a>ISO-2022-JP encoder state</a> is not
 <a title="iso-2022-jp encoder ASCII">ASCII</a>,
 <a title=concept-stream-prepend>prepend</a> <var>code point</var> to
 <var>stream</var>, set <a>ISO-2022-JP encoder state</a> to
 <a title="iso-2022-jp encoder ASCII">ASCII</a>, and return three bytes
 0x1B 0x28 0x42.

 <li><p>If <var>code point</var> is either U+00A5 or U+203E, and
 <a>ISO-2022-JP encoder state</a> is not
 <a title="iso-2022-jp encoder Roman">Roman</a>,
 <a title=concept-stream-prepend>prepend</a> <var>code point</var> to
 <var>stream</var>, set <a>ISO-2022-JP encoder state</a> to
 <a title="iso-2022-jp encoder Roman">Roman</a>, and return three bytes
 0x1B 0x28 0x4A.

 <li><p>If <var>code point</var> is U+2212, set it to U+FF0D.

 <li><p>Let <var>pointer</var> be the <a>index pointer</a> for
 <var>code point</var> in <a>index jis0208</a>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>If <a>ISO-2022-JP encoder state</a> is not
 <a title="iso-2022-jp encoder jis0208">jis0208</a>,
 <a title=concept-stream-prepend>prepend</a> <var>code point</var> to
 <var>stream</var>, set <a>ISO-2022-JP encoder state</a> to
 <a title="iso-2022-jp encoder jis0208">jis0208</a>, and return three bytes
 0x1B 0x24 0x42.

 <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 94) + 0x21.

 <li><p>Let <var>trail</var> be <var>pointer</var> % 94 + 0x21.

 <li><p>Return two bytes whose values are <var>lead</var> and
 <var>trail</var>.
</ol>


<h3><dfn>Shift_JIS</dfn></h3>

<h4><dfn>Shift_JIS decoder</dfn></h4>

<p><a>Shift_JIS</a>'s <a>decoder</a> has an associated
<dfn>Shift_JIS lead</dfn> (initially 0x00).

<p><a>Shift_JIS</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>Shift_JIS lead</a> is not 0x00, set <a>Shift_JIS lead</a> to 0x00 and
 return <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>Shift_JIS lead</a> is 0x00, return <a>finished</a>.

 <li>
  <p>If <a>Shift_JIS lead</a> is not 0x00, let <var>lead</var>
  be <a>Shift_JIS lead</a>, let <var>pointer</var> be null, set
  <a>Shift_JIS lead</a> to 0x00, and then run these substeps:

  <ol>
   <li><p>Let <var>offset</var> be 0x40, if <var>byte</var> is
   less than 0x7F, and 0x41 otherwise.

   <li><p>Let <var>lead offset</var> be 0x81, if <var>lead</var>
   is less than 0xA0, and 0xC1 otherwise.

   <li><p>If <var>byte</var> is in the range 0x40 to 0x7E, inclusive, or
   0x80 to 0xFC, inclusive, set <var>pointer</var> to
   (<var>lead</var> &minus; <var>lead offset</var>) &times; 188 + <var>byte</var> &minus; <var>offset</var>.

   <li><p>Let <var>code point</var> be null, if
   <var>pointer</var> is null, and the <a>index code point</a>
   for <var>pointer</var> in <a>index jis0208</a> otherwise.

   <li>
    <p>If <var>code point</var> is null and <var>pointer</var> is in the range
    8836 to 10528, inclusive, return a code point whose value is
    0xE000 + <var>pointer</var> &minus; 8836.

    <p class=note>This is interoperable legacy from Windows known as EUDC.
    <!-- PUA -->

   <li><p>If <var>code point</var> is null and <var>byte</var> is an
   <a>ASCII byte</a>, <a title=concept-stream-prepend>prepend</a>
   <var>byte</var> to <var>stream</var>.

   <li><p>If <var>code point</var> is null, return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li><p>If <var>byte</var> is an <a>ASCII byte</a> or 0x80, return a code point
 whose value is <var>byte</var>.
 <!-- Opera has 0x7E -->

 <li><p>If <var>byte</var> is in the range 0xA1 to 0xDF, inclusive, return
 a code point whose value is 0xFF61 + <var>byte</var> &minus; 0xA1.
 <!-- katakana -->

 <li><p>If <var>byte</var> is in the range 0x81 to 0x9F, inclusive, or 0xE0 to 0xFC,
 inclusive, set <a>Shift_JIS lead</a> to <var>byte</var> and return
 <a>continue</a>.

 <li><p>Return <a>error</a>.
</ol>


<h4><dfn>Shift_JIS encoder</dfn></h4>

<p><a>Shift_JIS</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a> or U+0080, return
 a byte whose value is <var>code point</var>.

 <li><p>If <var>code point</var> is U+00A5, return byte 0x5C.

 <li><p>If <var>code point</var> is U+203E, return byte 0x7E.

 <li><p>If <var>code point</var> is in the range U+FF61 to U+FF9F, inclusive, return
 a byte whose value is <var>code point</var> &minus; 0xFF61 + 0xA1.

 <li><p>If <var>code point</var> is U+2212, set it to U+FF0D.

 <li><p>Let <var>pointer</var> be the <a>index Shift_JIS pointer</a> for
 <var>code point</var>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 188).

 <li><p>Let <var>lead offset</var> be 0x81, if <var>lead</var> is
 less than 0x1F, and 0xC1 otherwise.
 <!-- 0xA0-0x81 -->

 <li><p>Let <var>trail</var> be <var>pointer</var> % 188.

 <li><p>Let <var>offset</var> be 0x40, if <var>trail</var> is
 less than 0x3F, and 0x41 otherwise.

 <li><p>Return two bytes whose values are
 <var>lead</var> + <var>lead offset</var> and
 <var>trail</var> + <var>offset</var>.
</ol>



<h2>Legacy multi-byte Korean encodings</h2>

<h3><dfn>EUC-KR</dfn></h3>

<h4><dfn>EUC-KR decoder</dfn></h4>

<p><a>EUC-KR</a>'s <a>decoder</a> has an associated
<dfn>EUC-KR lead</dfn> (initially 0x00).

<p><a>EUC-KR</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>EUC-KR lead</a> is not 0x00, set <a>EUC-KR lead</a> to 0x00
 and return <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>EUC-KR lead</a> is 0x00, return <a>finished</a>.

 <li>
  <p>If <a>EUC-KR lead</a> is not 0x00, let <var>lead</var> be
  <a>EUC-KR lead</a>, let <var>pointer</var> be null,
  set <a>EUC-KR lead</a> to 0x00, and then run these substeps:

  <ol>
   <li><p>If <var>byte</var> is in the range  0x41 to 0xFE, inclusive, set
   <var>pointer</var> to
   (<var>lead</var> &minus; 0x81) &times; 190 + (<var>byte</var> &minus; 0x41).

   <li><p>Let <var>code point</var> be null, if <var>pointer</var> is null,
   and the <a>index code point</a> for <var>pointer</var> in
   <a>index EUC-KR</a> otherwise.

   <li><p>If <var>code point</var> is null and <var>byte</var> is an
   <a>ASCII byte</a>, <a title=concept-stream-prepend>prepend</a>
   <var>byte</var> to <var>stream</var>.

   <li><p>If <var>code point</var> is null, return <a>error</a>.

   <li><p>Return a code point whose value is <var>code point</var>.
  </ol>

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return
 a code point whose value is <var>byte</var>.

 <li><p>If <var>byte</var> is in the range 0x81 to 0xFE, inclusive, set
 <a>EUC-KR lead</a> to <var>byte</var> and return <a>continue</a>.

 <li><p>Return <a>error</a>.
</ol>


<h4><dfn>EUC-KR encoder</dfn></h4>

<p><a>EUC-KR</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li><p>Let <var>pointer</var> be the <a>index pointer</a> for
 <var>code point</var> in <a>index EUC-KR</a>.

 <li><p>If <var>pointer</var> is null, return <a>error</a> with
 <var>code point</var>.

 <li><p>Let <var>lead</var> be floor(<var>pointer</var> / 190) + 0x81.

 <li><p>Let <var>trail</var> be <var>pointer</var> % 190 + 0x41.

 <li><p>Return two bytes whose values are <var>lead</var> and <var>trail</var>.
</ol>



<h2>Legacy miscellaneous encodings</h2>

<h3><dfn>replacement</dfn></h3>

<p class=note>The <a>replacement</a> <a>encoding</a> exists to prevent certain
attacks that abuse a mismatch between <a title=encoding>encodings</a> supported on
the server and the client.


<h4><dfn>replacement decoder</dfn></h4>

<p><a>replacement</a>'s <a>decoder</a> has an associated
<dfn>replacement error returned flag</dfn> (initially unset).

<p><a>replacement</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a>, return <a>finished</a>.

 <li><p>If <a>replacement error returned flag</a> is unset, set the
 <a>replacement error returned flag</a> and return <a>error</a>.

 <li><p>Return <a>finished</a>.
</ol>


<h3>Common infrastructure for <a>UTF-16BE</a> and <a>UTF-16LE</a></h3>

<h4><dfn>shared UTF-16 decoder</dfn></h4>

<p class="note no-backref">A byte order mark has priority over a <a>label</a> as it
has been found to be more accurate in deployed content. Therefore it is not part of the
<a>shared UTF-16 decoder</a> algorithm but rather the <a>decode</a> algorithm.

<p><a>shared UTF-16 decoder</a> has an associated <dfn>UTF-16 lead byte</dfn> and
<dfn>UTF-16 lead surrogate</dfn> (both initially null), and
<dfn>UTF-16BE decoder flag</dfn> (initially unset).

<p><a>shared UTF-16 decoder</a>'s <a>handler</a>, given a <var>stream</var>
and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a> and either
 <a>UTF-16 lead byte</a> or <a>UTF-16 lead surrogate</a> is not null, set
 <a>UTF-16 lead byte</a> and <a>UTF-16 lead surrogate</a> to null, and return
 <a>error</a>.

 <li><p>If <var>byte</var> is <a>end-of-stream</a> and
 <a>UTF-16 lead byte</a> and <a>UTF-16 lead surrogate</a> are null, return
 <a>finished</a>.

 <li><p>If <a>UTF-16 lead byte</a> is null, set <a>UTF-16 lead byte</a> to
 <var>byte</var> and return <a>continue</a>.

 <li>
  <p>Let <var>code unit</var> be the result of:

  <dl class=switch>
   <dt><a>UTF-16BE decoder flag</a> is set
   <dd><p>(<a>UTF-16 lead byte</a> &lt;&lt; 8) + <var>byte</var>.
   <dt><a>UTF-16BE decoder flag</a> is unset
   <dd><p>(<var>byte</var> &lt;&lt; 8) + <a>UTF-16 lead byte</a>.
  </dl>

  <p>Then set <a>UTF-16 lead byte</a> to null.

 <li>
  <p>If <a>UTF-16 lead surrogate</a> is not null, let
  <var>lead surrogate</var> be <a>UTF-16 lead surrogate</a>, set
  <a>UTF-16 lead surrogate</a> to null, and then run these substeps:

  <ol>
   <li><p>If <var>code unit</var> is in the range U+DC00 to U+DFFF, inclusive,
   return a code point whose value is
   0x10000 + ((<var>lead surrogate</var> &minus; 0xD800) &lt;&lt; 10) + (<var>code unit</var> &minus; 0xDC00).

   <li>
    <p>Let <var>bytes</var> be the return value of running these subsubsteps:

    <ol>
     <li><p>Let <var>byte1</var> be <var>code unit</var> >> 8.

     <li><p>Let <var>byte2</var> be <var>code unit</var> &amp; 0x00FF.

     <li>
      <p>Then return the bytes in order, switching on <a>UTF-16BE decoder flag</a>:

      <dl class=switch>
       <dt>Set
       <dd><p><var>byte1</var>, then <var>byte2</var>.
       <dt>Unset
       <dd><p><var>byte2</var>, then <var>byte1</var>.
      </dl>
    </ol>

   <li><p><a title=concept-stream-prepend>Prepend</a> the <var>bytes</var> to
   <var>stream</var> and return <a>error</a>.
   <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->
  </ol>

 <li><p>If <var>code unit</var> is in the range U+D800 to U+DBFF, inclusive, set
 <a>UTF-16 lead surrogate</a> to <var>code unit</var> and return
 <a>continue</a>.

 <li><p>If <var>code unit</var> is in the range U+DC00 to U+DFFF, inclusive,
 return <a>error</a>.
 <!-- unpaired surrogates; IE/WebKit output them, Gecko/Opera FFFD them -->

 <li><p>Return code point <var>code unit</var>.
</ol>


<h3><dfn>UTF-16BE</dfn></h3>

<h4><dfn>UTF-16BE decoder</dfn></h4>

<p><a>UTF-16BE</a>'s <a>decoder</a> is <a>shared UTF-16 decoder</a> with
its <a>UTF-16BE decoder flag</a> set.


<h3><dfn>UTF-16LE</dfn></h3>

<p class="note no-backref">Both "<code title>utf-16</code>" and
"<code title>utf-16le</code>" are <a title=label>labels</a> for
<a>UTF-16LE</a> to deal with deployed content.


<h4><dfn>UTF-16LE decoder</dfn></h4>

<p><a>UTF-16LE</a>'s <a>decoder</a> is <a>shared UTF-16 decoder</a>.


<h3><dfn>x-user-defined</dfn></h3>

<p class=note>While technically this is a <a>single-byte encoding</a>,
it is defined separately as it can be implemented algorithmically.

<!--
This encoding is silly, however, the web depends on it:

http://krijnhoetmer.nl/irc-logs/whatwg/20121003#l-461
http://krijnhoetmer.nl/irc-logs/whatwg/20121010#l-812

https://stackoverflow.com/questions/6986789/why-are-some-bytes-prefixed-with-0xf7-when-using-charset-x-user-defined-with-xm
-->

<h4><dfn>x-user-defined decoder</dfn></h4>

<p><a>x-user-defined</a>'s <a>decoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>byte</var>, runs these steps:

<ol>
 <li><p>If <var>byte</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>byte</var> is an <a>ASCII byte</a>, return
 a code point whose value is <var>byte</var>.

 <li><p>Return a code point whose value is 0xF780 + <var>byte</var> &minus; 0x80.
</ol>


<h4><dfn>x-user-defined encoder</dfn></h4>

<p><a>x-user-defined</a>'s <a>encoder</a>'s <a>handler</a>, given a
<var>stream</var> and <var>code point</var>, runs these steps:

<ol>
 <li><p>If <var>code point</var> is <a>end-of-stream</a>, return
 <a>finished</a>.

 <li><p>If <var>code point</var> is an <a>ASCII code point</a>, return
 a byte whose value is <var>code point</var>.

 <li><p>If <var>code point</var> is in the range U+F780 to U+F7FF, inclusive, return
 a byte whose value is <var>code point</var> &minus; 0xF780 + 0x80.

 <li><p>Return <a>error</a> with <var>code point</var>.
</ol>



<h2>Browser UI</h2>

<p>Browsers are encouraged to not enable overriding the encoding of a resource. If such a
feature is nonetheless present, browsers should not offer either
<a>UTF-16BE</a> or <a>UTF-16LE</a> as option due to aforementioned security
issues. Browsers also should disable this feature if the resource was decoded using either
<a>UTF-16BE</a> or <a>UTF-16LE</a>.



<h2 class=no-num>References</h2>

<div id=anolis-references></div>



<h2 class=no-num>Acknowledgments</h2>

<p>There have been a lot of people that have helped make encodings more
interoperable over the years and thereby furthered the goals of this
standard. Likewise many people have helped making this standard what it is
today.

<p>With that, many thanks to
Alan Chaney,
Alexander Shtuchkin,
Allen Wirfs-Brock,
Aneesh Agrawal,
Arkadiusz Michalski,
Asmus Freytag,
Ben Noordhuis,
Boris Zbarsky,
Cameron McCormack,
Charles McCathieNeville,
David Carlisle,
Domenic Denicola,
Dominique Haza√´l-Massieux,
Doug Ewell,
Erik van der Poel,
Ë≠öÊ∞∏Èãí (Frank Yung-Fong Tang),
Geoffrey Sneddon,
Glenn Maynard,
Gordon P. Hemsley,
Henri Sivonen,
Ian Hickson,
James Graham,
Jeffrey Yasskin,
John Tamplin,
Joshua Bell,
Êùë‰∫ïÁ¥î (Jun Murai),
Ïã†Ï†ïÏãù (Jungshik Shin),
Jxck,
Í∞ï ÏÑ±Ìõà (Kang Seonghoon),<!-- space is intentional: https://www.w3.org/Bugs/Public/show_bug.cgi?id=27675#c2 -->
Â∑ùÂπ°Â§™‰∏Ä (Kawabata Taichi),
Ken Lunde,
Ken Whistler,
Kenneth Russell,
Áî∞ÊùëÂÅ•‰∫∫ (Kent Tamura),
Leif Halvard Silli,
Makoto Kato,
Mark Callow,
Mark Crispin,
Mark Davis,
Martin D√ºrst,
Masatoshi Kimura,
Ms2ger,
Nigel Megitt,
Nigel Tao,
Norbert Lindenberg,
√òistein E. Andersen,
Peter Krefting,
Philip J√§genstedt,
Philip Taylor,
Richard Ishida,
Robbert Broersma,
Robert Mustacchi,
Ryan Dahl,
Shawn Steele,
Simon Montagu,
Simon Pieters,
Simon Sapin,
ÂØ∫Áî∞ÂÅ• (Takeshi Terada),
Vyacheslav Matva, and
ÊàêÁÄ¨„ÇÜ„ÅÑ (Yui Naruse)
for being awesome.

<p>This standard is written by
<a lang=nl href=https://annevankesteren.nl/>Anne van Kesteren</a>
(<a href=https://www.mozilla.org/>Mozilla</a>,
<a href=mailto:annevk@annevk.nl>annevk@annevk.nl</a>). The <a href=#api>API</a> chapter
was initially written by Joshua Bell (<a href=https://www.google.com/>Google</a>).

<p>Per <a rel=license href=https://creativecommons.org/publicdomain/zero/1.0/>CC0</a>, to
the extent possible under law, the editors have waived all copyright and related or
neighboring rights to this work.

<script id=head src=https://html.spec.whatwg.org/dfn.js></script>
